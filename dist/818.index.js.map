{"version":3,"file":"818.index.js","mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://backstage-blockchain-actions/./src/core/multisigs-collector.ts","webpack://backstage-blockchain-actions/./src/core/pick.ts","webpack://backstage-blockchain-actions/./src/core/filtered-collector.ts","webpack://backstage-blockchain-actions/./src/core/rbac-collector.ts","webpack://backstage-blockchain-actions/./src/helpers/backstage-export.ts","webpack://backstage-blockchain-actions/./src/utils/get-backstage-entities.ts"],"sourcesContent":["import { isApiEntity, isResourceEntity, stringifyEntityRef, RELATION_OWNED_BY, RELATION_API_CONSUMED_BY, RELATION_HAS_PART, parseEntityRef, } from \"@backstage/catalog-model\";\nexport class MultisigsCollector {\n    constructor(entities) {\n        this.systemComponents = [];\n        this.entities = [];\n        this.apiEntities = [];\n        this.resourceEntities = [];\n        this.multisigs = [];\n        this.contracts = [];\n        this.accessKeys = [];\n        this.entities = entities;\n        this.apiEntities = this.entities.filter(isApiEntity);\n        this.resourceEntities = this.entities.filter(isResourceEntity);\n        this.multisigs = this.apiEntities.filter((item) => { var _a; return ((_a = item.spec) === null || _a === void 0 ? void 0 : _a.type) === \"multisig-deployment\"; });\n        this.contracts = this.apiEntities.filter((item) => { var _a; return ((_a = item.spec) === null || _a === void 0 ? void 0 : _a.type) === \"contract-deployment\"; });\n        this.accessKeys = this.resourceEntities.filter((item) => { var _a; return ((_a = item.spec) === null || _a === void 0 ? void 0 : _a.type) === \"access-key\"; });\n        this.systemComponents = this.collectSystems();\n    }\n    normalizeEntities(list) {\n        return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n    }\n    collectSystems() {\n        const systemRefs = this.normalizeEntities(this.multisigs.map((item) => item.spec.system));\n        return systemRefs\n            .map((systemRef) => {\n            const system = this.entities.find((item) => stringifyEntityRef(item) === systemRef);\n            const components = this.collectComponents(system);\n            return {\n                title: system.metadata.title || system.metadata.name,\n                system,\n                components,\n            };\n        })\n            .sort((a, b) => a.system.metadata.name.localeCompare(b.system.metadata.name));\n    }\n    collectComponents(system) {\n        const componentRefs = system.relations.filter((r) => r.type === RELATION_HAS_PART &&\n            parseEntityRef(r.targetRef).kind === \"component\");\n        return componentRefs\n            .map((componentRef) => {\n            const component = this.entities.find((item) => stringifyEntityRef(item) === componentRef.targetRef);\n            return {\n                title: component.metadata.title || component.metadata.name,\n                component,\n                multisigs: this.multisigs\n                    .filter((item) => item.relations.some((r) => r.type === \"apiProvidedBy\" &&\n                    r.targetRef === componentRef.targetRef))\n                    .map((ms) => ({\n                    entity: ms,\n                    signers: this.collectSigners(ms),\n                })),\n            };\n        })\n            .sort((a, b) => a.component.metadata.name.localeCompare(b.component.metadata.name));\n    }\n    collectSigners(multisig) {\n        return multisig\n            .relations.filter((r) => r.type === RELATION_OWNED_BY &&\n            parseEntityRef(r.targetRef).kind !== \"group\")\n            .map((r) => {\n            const signer = this.entities.find((e) => stringifyEntityRef(e) === r.targetRef);\n            const owner = this.entities.find((e) => stringifyEntityRef(e) === signer.spec.owner);\n            return {\n                signer,\n                owner,\n            };\n        })\n            .sort((a, b) => a.owner.metadata.name.localeCompare(b.owner.metadata.name));\n    }\n    getAllApis() {\n        return this.apiEntities;\n    }\n    getAllResources() {\n        return this.resourceEntities;\n    }\n    getMultisigs() {\n        return this.systemComponents.flatMap((system) => system.components.flatMap((component) => component.multisigs));\n    }\n    getNearContracts() {\n        return this.contracts.filter((entity) => { var _a; return ((_a = entity.spec) === null || _a === void 0 ? void 0 : _a.network) === \"near\"; });\n    }\n    getSigners() {\n        const allSigners = this.getMultisigs().flatMap((ms) => ms.signers);\n        const uniqueSigners = allSigners.reduce((acc, signer) => {\n            const uid = signer.signer.metadata.uid;\n            if (uid && uid in allSigners) {\n                return acc;\n            }\n            if (!this.isQualifiedEntity(signer.signer)) {\n                return acc;\n            }\n            return Object.assign(Object.assign({}, acc), { [uid]: signer });\n        }, {});\n        return Object.values(uniqueSigners);\n    }\n    getMultisigAccessKeys() {\n        const signers = this.getSigners().filter((value) => { var _a; return ((_a = value.signer.spec) === null || _a === void 0 ? void 0 : _a.network) === \"near\"; });\n        const keys = signers.flatMap((value) => {\n            if (!value.signer.relations) {\n                return [];\n            }\n            return value.signer.relations\n                .filter((r) => r.type === RELATION_API_CONSUMED_BY &&\n                parseEntityRef(r.targetRef).kind === \"resource\")\n                .map((relation) => {\n                const key = this.entities.find((e) => stringifyEntityRef(e) === relation.targetRef);\n                return key;\n            });\n        });\n        return keys.filter(this.isEntity).filter(this.isQualifiedEntity);\n    }\n    getAccessKeysPerSigner() {\n        const signers = this.getSigners().filter((value) => { var _a; return ((_a = value.signer.spec) === null || _a === void 0 ? void 0 : _a.network) === \"near\"; });\n        const keysPerSigner = signers.reduce((acc, value) => {\n            if (!value.signer.relations) {\n                return acc;\n            }\n            const spec = JSON.parse(JSON.stringify(value.signer.spec));\n            const signer = spec.address;\n            const keys = value.signer.relations\n                .filter((r) => r.type === RELATION_API_CONSUMED_BY &&\n                parseEntityRef(r.targetRef).kind === \"resource\")\n                .map((relation) => {\n                const key = this.entities.find((e) => stringifyEntityRef(e) === relation.targetRef);\n                return key;\n            })\n                .filter(this.isEntity);\n            return Object.assign(Object.assign({}, acc), { [signer]: {\n                    owner: value.owner,\n                    signer: value.signer,\n                    keys,\n                } });\n        }, {});\n        return keysPerSigner;\n    }\n    getContractAccessKeys() {\n        const keys = this.contracts.flatMap((value) => {\n            if (!value.relations) {\n                return [];\n            }\n            return value.relations\n                .filter((r) => r.type === RELATION_API_CONSUMED_BY &&\n                parseEntityRef(r.targetRef).kind === \"resource\")\n                .map((relation) => {\n                const key = this.entities.find((e) => stringifyEntityRef(e) === relation.targetRef);\n                return key;\n            });\n        });\n        return keys.filter(this.isEntity);\n    }\n    getAllAccessKeys() {\n        return this.accessKeys;\n    }\n    getDeprecatedAccessKeys() {\n        const keys = this.getAllAccessKeys();\n        const deprecated = keys.filter((entity) => { var _a; return (_a = entity.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"deprecated\"); });\n        return deprecated;\n    }\n    getUnknownAccessKeys() {\n        const keys = this.getAllAccessKeys();\n        const unknown = keys.filter((entity) => { var _a; return (_a = entity.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"unknown\"); });\n        return unknown;\n    }\n    isQualifiedEntity(entity) {\n        var _a, _b;\n        return (!((_a = entity.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"retired\")) &&\n            !((_b = entity.metadata.tags) === null || _b === void 0 ? void 0 : _b.includes(\"allow-unknown\")));\n    }\n    isEntity(entity) {\n        return entity !== undefined;\n    }\n}\n","function getNestedValue(obj, key) {\n    return key\n        .split(\".\")\n        .reduce((o, k) => o && typeof o === \"object\" && k in o\n        ? o[k]\n        : undefined, obj);\n}\nfunction setNestedValue(obj, path, value) {\n    const keys = path.split(\".\");\n    let current = obj;\n    for (let i = 0; i < keys.length - 1; i++) {\n        const key = keys[i];\n        if (typeof current === \"object\" && current !== null && !(key in current)) {\n            current[key] = {};\n        }\n        current = current[key];\n    }\n    if (typeof current === \"object\" && current !== null) {\n        current[keys[keys.length - 1]] = value;\n    }\n}\nexport function pick(obj, whitelist) {\n    return whitelist.reduce((newObj, key) => {\n        const value = getNestedValue(obj, key);\n        if (value !== undefined) {\n            setNestedValue(newObj, key, value);\n        }\n        return newObj;\n    }, {});\n}\n","import { pick } from \"./pick\";\nconst ALLOWED_KINDS = [\"Component\", \"System\", \"API\"];\nconst ALLOWED_SPEC_FIELDS = [\n    \"type\",\n    \"deployedAt\",\n    \"address\",\n    \"network\",\n    \"networkType\",\n    \"deployment.source.startBlock\",\n];\nconst ALLOWED_METADATA_FIELDS = [\n    \"uid\",\n    \"namespace\",\n    \"name\",\n    \"title\",\n    \"annotations\",\n    \"tags\",\n];\nexport class FilteredCollector {\n    constructor(entities) {\n        this.srcEntities = entities;\n        this.entities = this.filterEntities();\n    }\n    filterSpec(spec) {\n        if (!spec)\n            return {};\n        return pick(spec, ALLOWED_SPEC_FIELDS);\n    }\n    filterMetadata(metadata) {\n        return pick(metadata, ALLOWED_METADATA_FIELDS);\n    }\n    filterEntities() {\n        return this.srcEntities\n            .filter((e) => ALLOWED_KINDS.includes(e.kind))\n            .map((e) => {\n            return {\n                apiVersion: e.apiVersion,\n                kind: e.kind,\n                metadata: this.filterMetadata(e.metadata),\n                spec: this.filterSpec(e.spec),\n            };\n        });\n    }\n}\n","import { isApiEntity, stringifyEntityRef, parseEntityRef, RELATION_API_PROVIDED_BY, RELATION_DEPENDS_ON, RELATION_HAS_PART, } from \"@backstage/catalog-model\";\nexport class RbacCollector {\n    constructor(entities) {\n        this.systemComponents = [];\n        this.entities = [];\n        this.contracts = [];\n        this.roleGroups = [];\n        this.entities = entities;\n        const apiEntities = this.entities.filter(isApiEntity);\n        this.contracts = apiEntities.filter((item) => { var _a; return ((_a = item.spec) === null || _a === void 0 ? void 0 : _a.type) === \"contract-deployment\"; });\n        this.roleGroups = apiEntities.filter((item) => { var _a; return ((_a = item.spec) === null || _a === void 0 ? void 0 : _a.type) === \"role-group\"; });\n        this.systemComponents = this.collectSystems();\n    }\n    normalizeEntities(list) {\n        return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n    }\n    collectSystems() {\n        const systemRefs = this.normalizeEntities(this.contracts\n            .filter((c) => { var _a; return !!((_a = c.spec) === null || _a === void 0 ? void 0 : _a.system); })\n            .map((c) => c.spec.system));\n        return systemRefs\n            .reduce((acc, systemRef) => {\n            const system = this.entities.find((item) => stringifyEntityRef(item) === systemRef);\n            const components = this.collectComponents(system);\n            if (components.some((c) => c.contracts.length)) {\n                return [\n                    ...acc,\n                    {\n                        title: system.metadata.title || system.metadata.name,\n                        system,\n                        components,\n                    },\n                ];\n            }\n            return acc;\n        }, [])\n            .sort((a, b) => a.system.metadata.name.localeCompare(b.system.metadata.name));\n    }\n    collectComponents(system) {\n        const componentRefs = system.relations.filter((r) => r.type === RELATION_HAS_PART &&\n            parseEntityRef(r.targetRef).kind === \"component\");\n        return componentRefs\n            .reduce((acc, componentRef) => {\n            const component = this.entities.find((item) => stringifyEntityRef(item) === componentRef.targetRef);\n            const contracts = this.collectContracts(componentRef);\n            if (contracts.length) {\n                return [\n                    ...acc,\n                    {\n                        title: component.metadata.title || component.metadata.name,\n                        component,\n                        contracts,\n                    },\n                ];\n            }\n            return acc;\n        }, [])\n            .sort((a, b) => a.component.metadata.name.localeCompare(b.component.metadata.name));\n    }\n    collectContracts(componentRef) {\n        return this.contracts\n            .filter((item) => {\n            var _a, _b;\n            return item.relations.some((r) => r.type === RELATION_API_PROVIDED_BY &&\n                r.targetRef === componentRef.targetRef) &&\n                ((_a = item.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"rbac\")) &&\n                ((_b = item.spec) === null || _b === void 0 ? void 0 : _b.lifecycle) === \"production\";\n        })\n            .map((entity) => ({\n            entity,\n            roles: this.collectRoles(entity),\n        }));\n    }\n    collectRoles(contract) {\n        return contract\n            .relations.filter((r) => r.type === RELATION_DEPENDS_ON &&\n            parseEntityRef(r.targetRef).kind === \"api\")\n            .reduce((acc, r) => {\n            const roleGroup = this.roleGroups.find((e) => stringifyEntityRef(e) === r.targetRef);\n            if (roleGroup && roleGroup.spec && roleGroup.spec.members) {\n                const specMembers = roleGroup.spec.members;\n                const members = specMembers.reduce((accMembers, m) => {\n                    var _a;\n                    const member = this.entities.find((e) => {\n                        var _a, _b, _c, _d;\n                        return ((_a = e.spec) === null || _a === void 0 ? void 0 : _a.type) &&\n                            // filter out role-groups since they are modeled with\n                            // the same fields as a blockchain address\n                            e.spec.type.toString() !== \"role-group\" &&\n                            ((_b = e.spec.address) === null || _b === void 0 ? void 0 : _b.toString().toLowerCase()) === m &&\n                            e.spec.network === ((_c = roleGroup.spec) === null || _c === void 0 ? void 0 : _c.network) &&\n                            e.spec.networkType === ((_d = roleGroup.spec) === null || _d === void 0 ? void 0 : _d.networkType);\n                    });\n                    if (member) {\n                        const ownerRef = parseEntityRef((_a = member.spec) === null || _a === void 0 ? void 0 : _a.owner);\n                        const owner = this.entities.find((e) => e.metadata.name === ownerRef.name);\n                        return [...accMembers, { member, owner }];\n                    }\n                    return accMembers;\n                }, []);\n                return [...acc, { role: roleGroup, members }];\n            }\n            return acc;\n        }, [])\n            .sort((a, b) => a.role.metadata.name.localeCompare(b.role.metadata.name));\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as core from \"@actions/core\";\nimport { sync } from \"glob\";\nimport fs from \"fs\";\nimport { simpleGit } from \"simple-git\";\nimport handlebars from \"handlebars\";\nimport { MultisigsCollector } from \"../core/multisigs-collector\";\nimport { FilteredCollector } from \"../core/filtered-collector\";\nimport { RbacCollector } from \"../core/rbac-collector\";\nimport { getBackstageEntities } from \"../utils/get-backstage-entities\";\nexport class BackstageExport {\n}\nexport const backstageExport = ({ backstage_url, template_path, output_path, testing, }) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!template_path || !output_path) {\n        throw new Error(\"set template_path and output_path for handlebars templating\");\n    }\n    const entities = yield getBackstageEntities({ backstage_url });\n    const multisigsCollector = new MultisigsCollector(entities);\n    const filteredCollector = new FilteredCollector(entities);\n    const rbacCollector = new RbacCollector(entities);\n    // console.log(JSON.stringify(multisigsCollector.systemComponents[0], null, 2));\n    const changedFiles = sync(`${template_path}**/*.hbs`).reduce((acc, templatePath) => {\n        const templateData = {\n            multisigSystemComponents: multisigsCollector.systemComponents,\n            contractSystemComponents: rbacCollector.systemComponents,\n            filteredEntities: JSON.stringify(filteredCollector.entities, null, 2),\n            testing,\n        };\n        if (reexportTemplate({\n            backstage_url,\n            output_path,\n            template_path,\n            templatePath,\n            templateData,\n        })) {\n            return [templatePath, ...acc];\n        }\n        return acc;\n    }, []);\n    if (testing) {\n        core.info(`Testing mode: ${changedFiles.length} changed files, exiting`);\n        return true;\n    }\n    if (changedFiles.length === 0) {\n        core.info(\"No changed files, nothing to commit\");\n        return false;\n    }\n    yield commitAndPushChanges(output_path);\n    return true;\n});\nfunction reexportTemplate(inputs) {\n    const outputPath = inputs.output_path +\n        inputs.templatePath.replace(inputs.template_path, \"\").replace(\".hbs\", \"\");\n    const compiledTemplate = handlebars.compile(fs.readFileSync(inputs.templatePath, { encoding: \"utf8\" }), {\n        strict: true,\n    });\n    const options = {\n        helpers: {\n            backstageLink: (entity) => {\n                if (!entity)\n                    return \"undefined\";\n                const md = entity.metadata;\n                return `${inputs.backstage_url}/catalog/${md.namespace}/${entity.kind}/${md.name}`;\n            },\n        },\n    };\n    const compiledContent = compiledTemplate(inputs.templateData, options);\n    const existingContent = fs.existsSync(outputPath) &&\n        fs.readFileSync(outputPath, {\n            encoding: \"utf-8\",\n        });\n    if (compiledContent !== existingContent) {\n        core.info(`Writing ${outputPath}: changed content`);\n        fs.writeFileSync(outputPath, compiledContent);\n        return true;\n    }\n    return false;\n}\nfunction commitAndPushChanges(path) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const git = simpleGit(\".\");\n        yield git.addConfig(\"user.email\", \"security@aurora.dev\");\n        yield git.addConfig(\"user.name\", \"Backstage Exporter\");\n        yield git.add(path);\n        const msg = \"chore(backstage): 🥷🏽 automatic re-export\";\n        yield git.commit(msg, undefined);\n        yield git.push();\n        core.info(\"Updated and pushed the changes\");\n        return true;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as core from \"@actions/core\";\nimport { CatalogClient } from \"@backstage/catalog-client\";\nimport { simpleGit } from \"simple-git\";\nfunction getFileContentFromRepo(repoUrl, filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const cloneDir = `/tmp/github-helpers-${Date.now()}`;\n        const git = simpleGit();\n        try {\n            yield git.clone(repoUrl, cloneDir, [\"--depth=1\"]);\n            yield git.cwd(cloneDir);\n            const { current } = yield git.branch();\n            const defaultBranch = current || \"main\";\n            const fileContent = yield git.show([\n                `${defaultBranch}:${filePath}`,\n            ]);\n            yield git.raw([\"rm\", \"-rf\", \".\"]);\n            return fileContent;\n        }\n        catch (error) {\n            throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n        }\n    });\n}\nfunction fetchBackstageEntitiesFromURL(backstageUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n        core.info(\"Connecting to Backstage to fetch available entities\");\n        const discoveryApi = {\n            getBaseUrl() {\n                return __awaiter(this, void 0, void 0, function* () {\n                    return `${backstageUrl}/api/catalog`;\n                });\n            },\n        };\n        const catalogClient = new CatalogClient({\n            discoveryApi,\n        });\n        const entities = yield catalogClient.getEntities({});\n        core.info(`Total backstage entities: ${entities.items.length}`);\n        return entities.items;\n    });\n}\nfunction fetchBackstageEntitiesFromRepo(backstageEntitiesRepo) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const serverUrl = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n        const repoUrl = `${serverUrl}/${backstageEntitiesRepo}`;\n        core.info(`Cloning ${repoUrl}`);\n        const content = yield getFileContentFromRepo(repoUrl, \"filteredEntities.json\");\n        return JSON.parse(content);\n    });\n}\nexport const getBackstageEntities = ({ backstage_url: backstageUrl, backstage_entities_repo: backstageEntitiesRepo, }) => __awaiter(void 0, void 0, void 0, function* () {\n    // repo takes a priority over the URL in order to avoid unnecessary runtime\n    // dependency\n    if (backstageEntitiesRepo) {\n        return fetchBackstageEntitiesFromRepo(backstageEntitiesRepo);\n    }\n    else if (backstageUrl) {\n        return fetchBackstageEntitiesFromURL(backstageUrl);\n    }\n    throw new Error(\"Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action\");\n});\n"],"names":[],"sourceRoot":""}