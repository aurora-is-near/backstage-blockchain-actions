{"version":3,"file":"288.index.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://backstage-blockchain-actions/./src/helpers/generate-component-matrix.ts","webpack://backstage-blockchain-actions/./src/octokit.ts","webpack://backstage-blockchain-actions/./src/utils/get-backstage-entities.ts","webpack://backstage-blockchain-actions/./src/utils/get-changed-files.ts"],"sourcesContent":["\"use strict\";\n/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateComponentMatrix = exports.GenerateComponentMatrix = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst github_1 = require(\"@actions/github\");\nconst get_changed_files_1 = require(\"../utils/get-changed-files\");\nconst path_1 = require(\"path\");\nconst fs_1 = require(\"fs\");\nconst glob_1 = require(\"glob\");\nconst get_backstage_entities_1 = require(\"../utils/get-backstage-entities\");\nclass GenerateComponentMatrix {\n}\nexports.GenerateComponentMatrix = GenerateComponentMatrix;\nconst DEFAULT_GO_VERSION = \"1.18\";\nfunction parseGoVersion(modFilePath) {\n    if ((0, fs_1.existsSync)(modFilePath)) {\n        const regex = /^go\\s+(\\S+)/m;\n        const match = regex.exec((0, fs_1.readFileSync)(modFilePath, \"utf8\"));\n        if (match)\n            return match[1];\n    }\n    core.warning(\"unable to detect go version\");\n    return DEFAULT_GO_VERSION;\n}\nfunction securityTier(entity) {\n    if (!entity.metadata.annotations)\n        return -1;\n    const tier = entity.metadata.annotations[\"aurora.dev/security-tier\"];\n    if (!tier)\n        return -1;\n    return parseInt(tier, 10);\n}\n// the annotation will have \"url:\" prefix - not a relative path\nfunction sourceLocation(entity) {\n    if (!entity.metadata.annotations)\n        return;\n    const loc = entity.metadata.annotations[\"backstage.io/source-location\"];\n    return loc;\n}\nfunction sourceLocationRelative(entity) {\n    const loc = sourceLocation(entity);\n    return loc.split(\"/\").slice(7).join(\"/\");\n}\nfunction sourceLocationDir(entity) {\n    const loc = sourceLocation(entity);\n    return loc.split(\"/\").slice(7, -1).join(\"/\");\n}\nfunction explicitRelativeLocation(loc) {\n    if (loc.startsWith(\"./\"))\n        return loc;\n    return [\".\", ...loc.split(\"/\")].join(\"/\");\n}\n/**\n * Finds the first parent directory that contains rootFile.\n * If the rootFile is not found, returns ./\n */\nfunction findRoot(dirName, rootFile) {\n    const dirs = dirName.split(\"/\");\n    core.info(`searching ${rootFile} for ${dirName}`);\n    for (;;) {\n        const testFile = (0, path_1.join)(\"./\", ...dirs, rootFile);\n        core.info(`checking: ${testFile}`);\n        if ((0, fs_1.existsSync)(testFile)) {\n            core.info(`Found ${rootFile} root for ${dirName}:`);\n            core.info(dirs.join(\"/\"));\n            break;\n        }\n        if (dirs.length === 0) {\n            core.info(`Unable to find ${rootFile} for ${dirName}, using the default`);\n            break;\n        }\n        dirs.pop();\n    }\n    return dirs.length > 0 ? dirs.join(\"/\") : \".\";\n}\nfunction hasInRoot(dirName, rootFilePattern) {\n    const dirs = dirName.split(\"/\");\n    const testFilePattern = (0, path_1.join)(\"./\", ...dirs, rootFilePattern);\n    if ((0, glob_1.sync)(testFilePattern).length > 0) {\n        core.info(`Found ${testFilePattern}`);\n        return true;\n    }\n    core.info(`Unable to find ${rootFilePattern} in ${dirName}`);\n    return false;\n}\nfunction inspectComponents(message, items) {\n    core.info(`${message} (${items.length}):`);\n    items.forEach((item) => core.info(` - ${item.metadata.name} at \"${sourceLocationRelative(item)}\"`));\n}\nfunction isSolidityItem(item, path) {\n    // Not sure if hasTags is necessary anymore\n    const hasTags = [\"ethereum\", \"aurora\"].some((tag) => item.metadata.tags?.includes(tag));\n    const hasFiles = hasInRoot(path, \"**/*.sol\");\n    return hasTags || hasFiles;\n}\nfunction componentConfig(item, runTests, ignoreFailures) {\n    const path = sourceLocationDir(item);\n    const isSolidity = isSolidityItem(item, path);\n    const isRust = item.metadata.tags?.includes(\"near\") || hasInRoot(path, \"Cargo.toml\");\n    const isGo = hasInRoot(path, \"go.mod\");\n    const isNode = hasInRoot(path, \"package.json\");\n    const runSlither = isSolidity && runTests;\n    const runClippy = isRust && runTests;\n    const runGoStaticChecks = isGo && runTests;\n    const runBiome = isNode && runTests;\n    // Slither is executed from monorepo's root, not from the \"path\"\n    // with the path passed as a target\n    // because of that the slither config will be in a subdir of the working dir\n    // and slither action won't find it automatically\n    const slitherArgs = hasInRoot(path, \"slither.config.json\")\n        ? `--config-file ${explicitRelativeLocation(path)}/slither.config.json`\n        : '--filter-paths \"node_modules|testing|test|lib\" --exclude timestamp,solc-version,naming-convention,assembly-usage';\n    return {\n        name: item.metadata.name,\n        tags: item.metadata.tags,\n        path,\n        securityTier: securityTier(item),\n        nodeRoot: findRoot(path, \"package.json\"),\n        goVersion: parseGoVersion(\"go.mod\"),\n        runSlither,\n        slitherArgs,\n        runClippy,\n        runGoStaticChecks,\n        runBiome,\n        ignoreFailures,\n        // backwards compatibility\n        allowTestsToFail: ignoreFailures,\n    };\n}\nfunction runTestsPolicy(entity, changed, eventName, workflow_force_all_checks_flag) {\n    if (workflow_force_all_checks_flag) {\n        core.info(`${entity.metadata.name}: CI runs because of workflow config (force_all_checks: true)`);\n        return true;\n    }\n    if (eventName !== \"pull_request\") {\n        core.info(`${entity.metadata.name}: CI runs because it's not a PR`);\n        return true;\n    }\n    if (entity.metadata.tags?.includes(\"ci-sec-changed-only\")) {\n        core.info(`${entity.metadata.name}: CI runs for changed only (changed: ${changed}) - via ci-sec-changed-only tag`);\n        return changed;\n    }\n    core.info(`${entity.metadata.name}: CI runs by default for all components (changed: ${changed}) - no ci-sec-changed-only tag`);\n    return true;\n}\nfunction ignoreFailuresPolicy(entity, _changed, _eventName, workflow_ignore_failures) {\n    if (workflow_ignore_failures) {\n        core.info(`${entity.metadata.name}: ignoring failures because of workflow config (ignore_failures: true)`);\n        return true;\n    }\n    if (entity.metadata.tags?.includes(\"ci-sec-disable\")) {\n        core.info(`${entity.metadata.name}: ignoring falures via ci-sec-disable tag`);\n        return true;\n    }\n    const tier = securityTier(entity);\n    const ignoreFailures = tier < 0;\n    core.info(`${entity.metadata.name}: CI runs will ignore failures based on security tier (${tier}: ${ignoreFailures})`);\n    return ignoreFailures;\n}\nconst generateComponentMatrix = async ({ backstage_url, backstage_entities_repo, force_all_checks, ignore_failures, }) => {\n    const entities = await (0, get_backstage_entities_1.getBackstageEntities)({\n        backstage_url,\n        backstage_entities_repo,\n    });\n    const serverUrl = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n    const repoUrl = [serverUrl, github_1.context.repo.owner, github_1.context.repo.repo].join(\"/\");\n    const componentItems = entities\n        .filter((item) => sourceLocation(item)?.startsWith(`url:${repoUrl}/`))\n        .filter((item) => item.kind === \"Component\");\n    inspectComponents(\"Component entities in this repo\", componentItems);\n    const eventName = process.env.GITHUB_EVENT_NAME;\n    const changedFiles = await (0, get_changed_files_1.getChangedFiles)(eventName);\n    core.info(`Changed files count: ${changedFiles.length}`);\n    const changedComponents = componentItems.filter((item) => changedFiles.some((file) => {\n        const loc = sourceLocationRelative(item);\n        return file.file.startsWith(loc);\n    }));\n    inspectComponents(\"Changed components\", changedComponents);\n    core.info(\"Generating component matrix...\");\n    const matrix = {\n        include: componentItems.map((item) => {\n            const changed = changedComponents.includes(item);\n            const runTests = runTestsPolicy(item, changed, eventName, force_all_checks);\n            const ignoreFailures = ignoreFailuresPolicy(item, changed, eventName, ignore_failures);\n            return componentConfig(item, runTests, ignoreFailures);\n        }),\n    };\n    core.info(JSON.stringify(matrix, null, 2));\n    return matrix;\n};\nexports.generateComponentMatrix = generateComponentMatrix;\n","\"use strict\";\n/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.octokit = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst github_1 = require(\"@actions/github\");\nconst githubToken = core.getInput(\"github_token\", { required: true });\nexports.octokit = (0, github_1.getOctokit)(githubToken).rest;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBackstageEntities = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst catalog_client_1 = require(\"@backstage/catalog-client\");\nconst simple_git_1 = require(\"simple-git\");\nconst getBackstageEntities = async ({ backstage_url: backstageUrl, backstage_entities_repo: backstageEntitiesRepo, }) => {\n    if (backstageUrl) {\n        try {\n            return fetchBackstageEntitiesFromURL(backstageUrl);\n        }\n        catch (err) {\n            /* empty */\n        }\n    }\n    // repo used as fallback to the URL in order to avoid unnecessary runtime\n    // dependency\n    if (backstageEntitiesRepo) {\n        return fetchBackstageEntitiesFromRepo(backstageEntitiesRepo);\n    }\n    throw new Error(\"Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action\");\n};\nexports.getBackstageEntities = getBackstageEntities;\nasync function getFileContentFromRepo(repoUrl, filePath) {\n    const cloneDir = `/tmp/github-helpers-${Date.now()}`;\n    const git = (0, simple_git_1.simpleGit)();\n    try {\n        await git.clone(repoUrl, cloneDir, [\"--depth=1\"]);\n        await git.cwd(cloneDir);\n        const { current } = await git.branch();\n        const defaultBranch = current || \"main\";\n        const fileContent = await git.show([\n            `${defaultBranch}:${filePath}`,\n        ]);\n        await git.raw([\"rm\", \"-rf\", \".\"]);\n        return fileContent;\n    }\n    catch (error) {\n        throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n    }\n}\nasync function fetchBackstageEntitiesFromURL(backstageUrl) {\n    core.info(\"Connecting to Backstage to fetch available entities\");\n    const discoveryApi = {\n        async getBaseUrl() {\n            return `${backstageUrl}/api/catalog`;\n        },\n    };\n    const catalogClient = new catalog_client_1.CatalogClient({\n        discoveryApi,\n    });\n    const entities = await catalogClient.getEntities({});\n    core.info(`Total backstage entities: ${entities.items.length}`);\n    return entities.items;\n}\nasync function fetchBackstageEntitiesFromRepo(backstageEntitiesRepo) {\n    const serverUrl = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n    const repoUrl = `${serverUrl}/${backstageEntitiesRepo}`;\n    core.info(`Cloning ${repoUrl}`);\n    const content = await getFileContentFromRepo(repoUrl, \"filteredEntities.json\");\n    return JSON.parse(content);\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getChangedFiles = exports.ChangeType = void 0;\nconst github = __importStar(require(\"@actions/github\"));\nconst core = __importStar(require(\"@actions/core\"));\nconst octokit_1 = require(\"../octokit\");\nvar ChangeType;\n(function (ChangeType) {\n    ChangeType[ChangeType[\"add\"] = 0] = \"add\";\n    ChangeType[ChangeType[\"edit\"] = 1] = \"edit\";\n    ChangeType[ChangeType[\"delete\"] = 2] = \"delete\";\n    ChangeType[ChangeType[\"any\"] = 3] = \"any\";\n})(ChangeType || (exports.ChangeType = ChangeType = {}));\nasync function getChangedFiles(eventName) {\n    if (!eventName) {\n        return [];\n    }\n    switch (eventName) {\n        case \"push\":\n            return getChangesFromSha();\n        default:\n            return getChangesFromPR();\n    }\n}\nexports.getChangedFiles = getChangedFiles;\nasync function getChangesFromSha() {\n    const beforeSha = github.context.payload.before;\n    const afterSha = github.context.payload.after;\n    const owner = github.context.payload.repository?.owner?.name;\n    const repo = github.context.payload.repository?.name;\n    if (!beforeSha || !afterSha || !repo || !owner) {\n        return [];\n    }\n    const changedFiles = await octokit_1.octokit.repos.compareCommits({\n        owner,\n        repo,\n        base: beforeSha,\n        head: afterSha,\n        mediaType: { format: \"sha\" },\n    });\n    const changes = changedFiles.data.files.map((f) => ({\n        file: f.filename,\n        changeType: parseStatus(f.status),\n        patch: f.patch,\n    }));\n    core.debug(\"found changed files:\");\n    for (const change of changes) {\n        core.debug(`  ${change.file}`);\n    }\n    return changes;\n}\nasync function getChangesFromPR() {\n    const pullRequest = github.context.payload.pull_request;\n    if (!pullRequest) {\n        return [];\n    }\n    const listFilesResponse = await octokit_1.octokit.pulls.listFiles({\n        owner: github.context.repo.owner,\n        repo: github.context.repo.repo,\n        pull_number: pullRequest.number,\n    });\n    const changes = listFilesResponse.data.map((f) => ({\n        file: f.filename,\n        changeType: parseStatus(f.status),\n        patch: f.patch,\n    }));\n    core.debug(\"found changed files:\");\n    for (const change of changes) {\n        core.debug(`  ${change.file}`);\n    }\n    return changes;\n}\nfunction parseStatus(status) {\n    switch (status) {\n        case \"added\":\n            return ChangeType.add;\n        case \"removed\":\n            return ChangeType.delete;\n        case \"modified\":\n            return ChangeType.edit;\n        default:\n            return ChangeType.edit;\n    }\n}\n"],"names":[],"sourceRoot":""}