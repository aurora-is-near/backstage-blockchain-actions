{"version":3,"file":"795.index.js","mappings":";;;;;;;;;;;;AAAA;AAqCA;AASA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9RA;AACA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxDA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAEA;AAMA;AACA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AAEA;AAOA;;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AAEA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA","sources":["webpack://backstage-blockchain-actions/./src/core/multisigs-collector.ts","webpack://backstage-blockchain-actions/./src/core/pick.ts","webpack://backstage-blockchain-actions/./src/core/filtered-collector.ts","webpack://backstage-blockchain-actions/./src/helpers/backstage-export.ts","webpack://backstage-blockchain-actions/./src/utils/get-backstage-entities.ts"],"sourcesContent":["import {\n  isApiEntity,\n  isResourceEntity,\n  stringifyEntityRef,\n  RELATION_OWNED_BY,\n  RELATION_API_CONSUMED_BY,\n  RELATION_HAS_PART,\n  parseEntityRef,\n} from \"@backstage/catalog-model\";\nimport type { Entity } from \"@backstage/catalog-model\";\n\ntype MultisigSigner = {\n  signer: Entity;\n  owner?: Entity;\n};\ntype MultisigSignerAndKeysComposed = MultisigSigner & { keys: Entity[] };\ntype MultisigSignerAndKeys = {\n  [K in keyof MultisigSignerAndKeysComposed]: MultisigSignerAndKeysComposed[K];\n};\n\ntype MultisigInfo = {\n  entity: Entity;\n  signers: MultisigSigner[];\n};\n\ntype ComponentMultisigs = {\n  title: string;\n  component: Entity;\n  multisigs: MultisigInfo[];\n};\n\ntype SystemComponents = {\n  title: string;\n  system: Entity;\n  components: ComponentMultisigs[];\n};\n\nexport class MultisigsCollector {\n  systemComponents: SystemComponents[] = [];\n  private entities: Entity[] = [];\n  private apiEntities: Entity[] = [];\n  private resourceEntities: Entity[] = [];\n  private multisigs: Entity[] = [];\n  private contracts: Entity[] = [];\n  private accessKeys: Entity[] = [];\n\n  constructor(entities: Entity[]) {\n    this.entities = entities;\n    this.apiEntities = this.entities.filter(isApiEntity);\n    this.resourceEntities = this.entities.filter(isResourceEntity);\n    this.multisigs = this.apiEntities.filter(\n      (item) => item.spec?.type === \"multisig-deployment\",\n    );\n    this.contracts = this.apiEntities.filter(\n      (item) => item.spec?.type === \"contract-deployment\",\n    );\n    this.accessKeys = this.resourceEntities.filter(\n      (item) => item.spec?.type === \"access-key\",\n    );\n    this.systemComponents = this.collectSystems();\n  }\n\n  normalizeEntities(list: string[]) {\n    return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n  }\n\n  collectSystems() {\n    const systemRefs = this.normalizeEntities(\n      this.multisigs.map((item) => item.spec!.system! as string),\n    );\n    return systemRefs\n      .map((systemRef) => {\n        const system = this.entities.find(\n          (item) => stringifyEntityRef(item) === systemRef,\n        )!;\n        const components = this.collectComponents(system);\n\n        return {\n          title: system.metadata.title || system.metadata.name,\n          system,\n          components,\n        };\n      })\n      .sort((a, b) =>\n        a.system.metadata.name.localeCompare(b.system.metadata.name),\n      );\n  }\n\n  collectComponents(system: Entity) {\n    const componentRefs = system.relations!.filter(\n      (r) =>\n        r.type === RELATION_HAS_PART &&\n        parseEntityRef(r.targetRef).kind === \"component\",\n    );\n    return componentRefs\n      .map((componentRef) => {\n        const component = this.entities.find(\n          (item) => stringifyEntityRef(item) === componentRef.targetRef,\n        )!;\n        return {\n          title: component.metadata.title || component.metadata.name,\n          component,\n          multisigs: this.multisigs\n            .filter((item) =>\n              item.relations!.some(\n                (r) =>\n                  r.type === \"apiProvidedBy\" &&\n                  r.targetRef === componentRef.targetRef,\n              ),\n            )\n            .map((ms) => ({\n              entity: ms,\n              signers: this.collectSigners(ms),\n            })),\n        };\n      })\n      .sort((a, b) =>\n        a.component.metadata.name.localeCompare(b.component.metadata.name),\n      );\n  }\n\n  collectSigners(multisig: Entity) {\n    return multisig\n      .relations!.filter(\n        (r) =>\n          r.type === RELATION_OWNED_BY &&\n          parseEntityRef(r.targetRef).kind !== \"group\",\n      )\n      .map((r) => {\n        const signer = this.entities.find(\n          (e) => stringifyEntityRef(e) === r.targetRef,\n        )!;\n        const owner = this.entities.find(\n          (e) => stringifyEntityRef(e) === signer.spec!.owner,\n        )!;\n        return {\n          signer,\n          owner,\n        };\n      })\n      .sort((a, b) =>\n        a.owner.metadata.name.localeCompare(b.owner.metadata.name),\n      );\n  }\n\n  getAllApis() {\n    return this.apiEntities;\n  }\n\n  getAllResources() {\n    return this.resourceEntities;\n  }\n\n  getMultisigs() {\n    return this.systemComponents.flatMap((system) =>\n      system.components.flatMap((component) => component.multisigs),\n    );\n  }\n\n  getNearContracts() {\n    return this.contracts.filter((entity) => entity.spec?.network === \"near\");\n  }\n\n  getSigners() {\n    const allSigners = this.getMultisigs().flatMap((ms) => ms.signers);\n    const uniqueSigners = allSigners.reduce<{ [uid: string]: MultisigSigner }>(\n      (acc, signer) => {\n        const uid = signer.signer.metadata.uid;\n        if (uid && uid in allSigners) {\n          return acc;\n        }\n        if (!this.isQualifiedEntity(signer.signer)) {\n          return acc;\n        }\n        return { ...acc, [uid as string]: signer };\n      },\n      {},\n    );\n    return Object.values(uniqueSigners);\n  }\n\n  getMultisigAccessKeys(): Entity[] {\n    const signers = this.getSigners().filter(\n      (value) => value.signer.spec?.network === \"near\",\n    );\n    const keys = signers.flatMap((value) => {\n      if (!value.signer.relations) {\n        return [];\n      }\n      return value.signer.relations\n        .filter(\n          (r) =>\n            r.type === RELATION_API_CONSUMED_BY &&\n            parseEntityRef(r.targetRef).kind === \"resource\",\n        )\n        .map((relation) => {\n          const key = this.entities.find(\n            (e) => stringifyEntityRef(e) === relation.targetRef,\n          );\n          return key;\n        });\n    });\n\n    return keys.filter<Entity>(this.isEntity).filter(this.isQualifiedEntity);\n  }\n\n  getAccessKeysPerSigner() {\n    const signers = this.getSigners().filter(\n      (value) => value.signer.spec?.network === \"near\",\n    );\n    const keysPerSigner = signers.reduce<{\n      [s: string]: MultisigSignerAndKeys;\n    }>((acc, value) => {\n      if (!value.signer.relations) {\n        return acc;\n      }\n      const spec = JSON.parse(JSON.stringify(value.signer.spec));\n      const signer: string = spec.address;\n      const keys = value.signer.relations\n        .filter(\n          (r) =>\n            r.type === RELATION_API_CONSUMED_BY &&\n            parseEntityRef(r.targetRef).kind === \"resource\",\n        )\n        .map((relation) => {\n          const key = this.entities.find(\n            (e) => stringifyEntityRef(e) === relation.targetRef,\n          );\n          return key;\n        })\n        .filter<Entity>(this.isEntity);\n\n      return {\n        ...acc,\n        [signer]: {\n          owner: value.owner,\n          signer: value.signer,\n          keys,\n        },\n      };\n    }, {});\n\n    return keysPerSigner;\n  }\n\n  getContractAccessKeys(): Entity[] {\n    const keys = this.contracts.flatMap((value) => {\n      if (!value.relations) {\n        return [];\n      }\n      return value.relations\n        .filter(\n          (r) =>\n            r.type === RELATION_API_CONSUMED_BY &&\n            parseEntityRef(r.targetRef).kind === \"resource\",\n        )\n        .map((relation) => {\n          const key = this.entities.find(\n            (e) => stringifyEntityRef(e) === relation.targetRef,\n          );\n          return key;\n        });\n    });\n    return keys.filter<Entity>(this.isEntity);\n  }\n\n  getAllAccessKeys(): Entity[] {\n    return this.accessKeys;\n  }\n\n  getDeprecatedAccessKeys(): Entity[] {\n    const keys = this.getAllAccessKeys();\n    const deprecated = keys.filter(\n      (entity) => entity.metadata.tags?.includes(\"deprecated\"),\n    );\n    return deprecated;\n  }\n\n  getUnknownAccessKeys(): Entity[] {\n    const keys = this.getAllAccessKeys();\n    const unknown = keys.filter(\n      (entity) => entity.metadata.tags?.includes(\"unknown\"),\n    );\n    return unknown;\n  }\n\n  private isQualifiedEntity(entity: Entity) {\n    return (\n      !entity.metadata.tags?.includes(\"retired\") &&\n      !entity.metadata.tags?.includes(\"allow-unknown\")\n    );\n  }\n\n  private isEntity(entity: Entity | undefined): entity is Entity {\n    return entity !== undefined;\n  }\n}\n","type NestedKeys<T> = {\n  [K in keyof T]: K extends string\n    ? `${K}` | `${K}.${NestedKeys<T[K]>}`\n    : never;\n}[keyof T] extends infer X\n  ? X extends string\n    ? X\n    : never\n  : never;\n\nfunction getNestedValue<T, K extends NestedKeys<T>>(obj: T, key: K): unknown {\n  return (key as string)\n    .split(\".\")\n    .reduce(\n      (o: unknown, k: string) =>\n        o && typeof o === \"object\" && k in o\n          ? (o as Record<string, unknown>)[k]\n          : undefined,\n      obj,\n    );\n}\n\nfunction setNestedValue<T, K extends NestedKeys<T>>(\n  obj: T,\n  path: K,\n  value: unknown,\n): void {\n  const keys = (path as string).split(\".\");\n  let current: unknown = obj;\n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    if (typeof current === \"object\" && current !== null && !(key in current)) {\n      (current as Record<string, unknown>)[key] = {};\n    }\n    current = (current as Record<string, unknown>)[key];\n  }\n  if (typeof current === \"object\" && current !== null) {\n    (current as Record<string, unknown>)[keys[keys.length - 1]] = value;\n  }\n}\n\nexport function pick<T>(obj: T, whitelist: NestedKeys<T>[]): Partial<T> {\n  return whitelist.reduce((newObj, key) => {\n    const value = getNestedValue(obj, key);\n    if (value !== undefined) {\n      setNestedValue(newObj, key, value);\n    }\n    return newObj;\n  }, {} as Partial<T>);\n}\n","import type { JsonObject } from \"@backstage/types\";\nimport type { Entity } from \"@backstage/catalog-model\";\nimport { pick } from \"./pick\";\n\nconst ALLOWED_KINDS = [\"Component\", \"System\", \"API\"];\nconst ALLOWED_SPEC_FIELDS = [\n  \"type\",\n  \"deployedAt\",\n  \"address\",\n  \"network\",\n  \"networkType\",\n  \"deployment.source.startBlock\",\n];\nconst ALLOWED_METADATA_FIELDS = [\n  \"uid\",\n  \"namespace\",\n  \"name\",\n  \"title\",\n  \"annotations\",\n  \"tags\",\n];\n\nexport class FilteredCollector {\n  entities: Entity[];\n  private srcEntities: Entity[];\n\n  constructor(entities: Entity[]) {\n    this.srcEntities = entities;\n    this.entities = this.filterEntities();\n  }\n\n  normalizeEntities(list: string[]) {\n    return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n  }\n\n  filterSpec(spec?: JsonObject) {\n    if (!spec) return {};\n    return pick(spec, ALLOWED_SPEC_FIELDS);\n  }\n\n  filterMetadata(metadata: JsonObject) {\n    return pick(metadata, ALLOWED_METADATA_FIELDS);\n  }\n\n  filterEntities() {\n    return this.srcEntities\n      .filter((e) => ALLOWED_KINDS.includes(e.kind))\n      .map((e) => {\n        return {\n          apiVersion: e.apiVersion,\n          kind: e.kind,\n          metadata: this.filterMetadata(e.metadata),\n          spec: this.filterSpec(e.spec),\n        } as Entity;\n      });\n  }\n}\n","import * as core from \"@actions/core\";\nimport { sync } from \"glob\";\nimport type { Entity } from \"@backstage/catalog-model\";\nimport fs from \"fs\";\nimport { simpleGit } from \"simple-git\";\nimport handlebars from \"handlebars\";\n\nimport { MultisigsCollector } from \"../core/multisigs-collector\";\nimport { FilteredCollector } from \"../core/filtered-collector\";\nimport { getBackstageEntities } from \"../utils/get-backstage-entities\";\n\nexport class BackstageExport {\n  backstage_url?: string;\n  template_path?: string;\n  output_path?: string;\n  testing?: boolean;\n}\n\nexport const backstageExport = async ({\n  backstage_url,\n  template_path,\n  output_path,\n  testing,\n}: BackstageExport) => {\n  if (!template_path || !output_path) {\n    throw new Error(\n      \"set template_path and output_path for handlebars templating\",\n    );\n  }\n\n  const entities = await getBackstageEntities({ backstage_url });\n\n  const multisigsCollector = new MultisigsCollector(entities);\n  const filteredCollector = new FilteredCollector(entities);\n\n  // console.log(JSON.stringify(multisigsCollector.systemComponents[0], null, 2));\n  const changedFiles = sync(`${template_path}**/*.hbs`).reduce(\n    (acc, templatePath) => {\n      const templateData = {\n        multisigSystemComponents: multisigsCollector.systemComponents,\n        filteredEntities: JSON.stringify(filteredCollector.entities, null, 2),\n        testing,\n      };\n\n      if (\n        reexportTemplate({\n          backstage_url,\n          output_path,\n          template_path,\n          templatePath,\n          templateData,\n        })\n      ) {\n        return [templatePath, ...acc];\n      }\n\n      return acc;\n    },\n    [] as string[],\n  );\n\n  if (testing) {\n    core.info(`Testing mode: ${changedFiles.length} changed files, exiting`);\n    return true;\n  }\n\n  if (changedFiles.length === 0) {\n    core.info(\"No changed files, nothing to commit\");\n    return false;\n  }\n\n  await commitAndPushChanges(output_path);\n  return true;\n};\n\nfunction reexportTemplate(\n  inputs: BackstageExport & { templatePath: string; templateData: {} },\n) {\n  const outputPath =\n    inputs.output_path! +\n    inputs.templatePath.replace(inputs.template_path!, \"\").replace(\".hbs\", \"\");\n\n  const compiledTemplate = handlebars.compile(\n    fs.readFileSync(inputs.templatePath, { encoding: \"utf8\" }),\n    {\n      strict: true,\n    },\n  );\n\n  const options = {\n    helpers: {\n      backstageLink: (entity: Entity) => {\n        if (!entity) return \"undefined\";\n        const md = entity.metadata;\n        return `${inputs.backstage_url}/catalog/${md.namespace}/${entity.kind}/${md.name}`;\n      },\n    },\n  };\n\n  const compiledContent = compiledTemplate(inputs.templateData, options);\n\n  const existingContent =\n    fs.existsSync(outputPath) &&\n    fs.readFileSync(outputPath, {\n      encoding: \"utf-8\",\n    });\n  if (compiledContent !== existingContent) {\n    core.info(`Writing ${outputPath}: changed content`);\n    fs.writeFileSync(outputPath, compiledContent);\n    return true;\n  }\n  return false;\n}\n\nasync function commitAndPushChanges(path: string) {\n  const git = simpleGit(\".\");\n  await git.addConfig(\"user.email\", \"security@aurora.dev\");\n  await git.addConfig(\"user.name\", \"Backstage Exporter\");\n  await git.add(path);\n  const msg = \"chore(backstage): 🥷🏽 automatic re-export\";\n  await git.commit(msg, undefined);\n  await git.push();\n  core.info(\"Updated and pushed the changes\");\n  return true;\n}\n","import * as core from \"@actions/core\";\nimport { CatalogClient } from \"@backstage/catalog-client\";\nimport type { Entity } from \"@backstage/catalog-model\";\nimport { simpleGit } from \"simple-git\";\n\ninterface GetBackstageEntities {\n  backstage_url?: string;\n  backstage_entities_repo?: string;\n}\n\nasync function getFileContentFromRepo(\n  repoUrl: string,\n  filePath: string,\n): Promise<string> {\n  const cloneDir = `/tmp/github-helpers-${Date.now()}`;\n  const git = simpleGit();\n\n  try {\n    await git.clone(repoUrl, cloneDir, [\"--depth=1\"]);\n    await git.cwd(cloneDir);\n\n    const { current } = await git.branch();\n    const defaultBranch = current || \"main\";\n    const fileContent: string = await git.show([\n      `${defaultBranch}:${filePath}`,\n    ]);\n\n    await git.raw([\"rm\", \"-rf\", \".\"]);\n    return fileContent;\n  } catch (error) {\n    throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n  }\n}\n\nasync function fetchBackstageEntitiesFromURL(backstageUrl: string) {\n  core.info(\"Connecting to Backstage to fetch available entities\");\n\n  const discoveryApi = {\n    async getBaseUrl() {\n      return `${backstageUrl}/api/catalog`;\n    },\n  };\n  const catalogClient = new CatalogClient({\n    discoveryApi,\n  });\n\n  const entities = await catalogClient.getEntities({});\n  core.info(`Total backstage entities: ${entities.items.length}`);\n\n  return entities.items;\n}\n\nasync function fetchBackstageEntitiesFromRepo(backstageEntitiesRepo: string) {\n  const serverUrl = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n  const repoUrl = `${serverUrl}/${backstageEntitiesRepo}`;\n  core.info(`Cloning ${repoUrl}`);\n  const content = await getFileContentFromRepo(\n    repoUrl,\n    \"filteredEntities.json\",\n  );\n  return JSON.parse(content) as Entity[];\n}\n\nexport const getBackstageEntities = async ({\n  backstage_url: backstageUrl,\n  backstage_entities_repo: backstageEntitiesRepo,\n}: GetBackstageEntities) => {\n  // repo takes a priority over the URL in order to avoid unnecessary runtime\n  // dependency\n  if (backstageEntitiesRepo) {\n    return fetchBackstageEntitiesFromRepo(backstageEntitiesRepo);\n  } else if (backstageUrl) {\n    return fetchBackstageEntitiesFromURL(backstageUrl);\n  }\n  throw new Error(\n    \"Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action\",\n  );\n};\n"],"names":[],"sourceRoot":""}