{"version":3,"file":"125.index.js","mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://backstage-blockchain-actions/./src/core/multisigs-collector.ts","webpack://backstage-blockchain-actions/./src/helpers/backstage-metrics.ts","webpack://backstage-blockchain-actions/./src/utils/get-backstage-entities.ts"],"sourcesContent":["import { isApiEntity, isResourceEntity, stringifyEntityRef, RELATION_OWNED_BY, RELATION_API_CONSUMED_BY, RELATION_HAS_PART, parseEntityRef, } from \"@backstage/catalog-model\";\nexport class MultisigsCollector {\n    constructor(entities) {\n        this.systemComponents = [];\n        this.entities = [];\n        this.apiEntities = [];\n        this.resourceEntities = [];\n        this.multisigs = [];\n        this.contracts = [];\n        this.accessKeys = [];\n        this.entities = entities;\n        this.apiEntities = this.entities.filter(isApiEntity);\n        this.resourceEntities = this.entities.filter(isResourceEntity);\n        this.multisigs = this.apiEntities.filter((item) => { var _a; return ((_a = item.spec) === null || _a === void 0 ? void 0 : _a.type) === \"multisig-deployment\"; });\n        this.contracts = this.apiEntities.filter((item) => { var _a; return ((_a = item.spec) === null || _a === void 0 ? void 0 : _a.type) === \"contract-deployment\"; });\n        this.accessKeys = this.resourceEntities.filter((item) => { var _a; return ((_a = item.spec) === null || _a === void 0 ? void 0 : _a.type) === \"access-key\"; });\n        this.systemComponents = this.collectSystems();\n    }\n    normalizeEntities(list) {\n        return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n    }\n    collectSystems() {\n        const systemRefs = this.normalizeEntities(this.multisigs.map((item) => item.spec.system));\n        return systemRefs\n            .map((systemRef) => {\n            const system = this.entities.find((item) => stringifyEntityRef(item) === systemRef);\n            const components = this.collectComponents(system);\n            return {\n                title: system.metadata.title || system.metadata.name,\n                system,\n                components,\n            };\n        })\n            .sort((a, b) => a.system.metadata.name.localeCompare(b.system.metadata.name));\n    }\n    collectComponents(system) {\n        const componentRefs = system.relations.filter((r) => r.type === RELATION_HAS_PART &&\n            parseEntityRef(r.targetRef).kind === \"component\");\n        return componentRefs\n            .map((componentRef) => {\n            const component = this.entities.find((item) => stringifyEntityRef(item) === componentRef.targetRef);\n            return {\n                title: component.metadata.title || component.metadata.name,\n                component,\n                multisigs: this.multisigs\n                    .filter((item) => item.relations.some((r) => r.type === \"apiProvidedBy\" &&\n                    r.targetRef === componentRef.targetRef))\n                    .map((ms) => ({\n                    entity: ms,\n                    signers: this.collectSigners(ms),\n                })),\n            };\n        })\n            .sort((a, b) => a.component.metadata.name.localeCompare(b.component.metadata.name));\n    }\n    collectSigners(multisig) {\n        return multisig\n            .relations.filter((r) => r.type === RELATION_OWNED_BY &&\n            parseEntityRef(r.targetRef).kind !== \"group\")\n            .map((r) => {\n            const signer = this.entities.find((e) => stringifyEntityRef(e) === r.targetRef);\n            const owner = this.entities.find((e) => stringifyEntityRef(e) === signer.spec.owner);\n            return {\n                signer,\n                owner,\n            };\n        })\n            .sort((a, b) => a.owner.metadata.name.localeCompare(b.owner.metadata.name));\n    }\n    getAllApis() {\n        return this.apiEntities;\n    }\n    getAllResources() {\n        return this.resourceEntities;\n    }\n    getMultisigs() {\n        return this.systemComponents.flatMap((system) => system.components.flatMap((component) => component.multisigs));\n    }\n    getNearContracts() {\n        return this.contracts.filter((entity) => { var _a; return ((_a = entity.spec) === null || _a === void 0 ? void 0 : _a.network) === \"near\"; });\n    }\n    getSigners() {\n        const allSigners = this.getMultisigs().flatMap((ms) => ms.signers);\n        const uniqueSigners = allSigners.reduce((acc, signer) => {\n            const uid = signer.signer.metadata.uid;\n            if (uid && uid in allSigners) {\n                return acc;\n            }\n            if (!this.isQualifiedEntity(signer.signer)) {\n                return acc;\n            }\n            return Object.assign(Object.assign({}, acc), { [uid]: signer });\n        }, {});\n        return Object.values(uniqueSigners);\n    }\n    getMultisigAccessKeys() {\n        const signers = this.getSigners().filter((value) => { var _a; return ((_a = value.signer.spec) === null || _a === void 0 ? void 0 : _a.network) === \"near\"; });\n        const keys = signers.flatMap((value) => {\n            if (!value.signer.relations) {\n                return [];\n            }\n            return value.signer.relations\n                .filter((r) => r.type === RELATION_API_CONSUMED_BY &&\n                parseEntityRef(r.targetRef).kind === \"resource\")\n                .map((relation) => {\n                const key = this.entities.find((e) => stringifyEntityRef(e) === relation.targetRef);\n                return key;\n            });\n        });\n        return keys.filter(this.isEntity).filter(this.isQualifiedEntity);\n    }\n    getAccessKeysPerSigner() {\n        const signers = this.getSigners().filter((value) => { var _a; return ((_a = value.signer.spec) === null || _a === void 0 ? void 0 : _a.network) === \"near\"; });\n        const keysPerSigner = signers.reduce((acc, value) => {\n            if (!value.signer.relations) {\n                return acc;\n            }\n            const spec = JSON.parse(JSON.stringify(value.signer.spec));\n            const signer = spec.address;\n            const keys = value.signer.relations\n                .filter((r) => r.type === RELATION_API_CONSUMED_BY &&\n                parseEntityRef(r.targetRef).kind === \"resource\")\n                .map((relation) => {\n                const key = this.entities.find((e) => stringifyEntityRef(e) === relation.targetRef);\n                return key;\n            })\n                .filter(this.isEntity);\n            return Object.assign(Object.assign({}, acc), { [signer]: {\n                    owner: value.owner,\n                    signer: value.signer,\n                    keys,\n                } });\n        }, {});\n        return keysPerSigner;\n    }\n    getContractAccessKeys() {\n        const keys = this.contracts.flatMap((value) => {\n            if (!value.relations) {\n                return [];\n            }\n            return value.relations\n                .filter((r) => r.type === RELATION_API_CONSUMED_BY &&\n                parseEntityRef(r.targetRef).kind === \"resource\")\n                .map((relation) => {\n                const key = this.entities.find((e) => stringifyEntityRef(e) === relation.targetRef);\n                return key;\n            });\n        });\n        return keys.filter(this.isEntity);\n    }\n    getAllAccessKeys() {\n        return this.accessKeys;\n    }\n    getDeprecatedAccessKeys() {\n        const keys = this.getAllAccessKeys();\n        const deprecated = keys.filter((entity) => { var _a; return (_a = entity.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"deprecated\"); });\n        return deprecated;\n    }\n    getUnknownAccessKeys() {\n        const keys = this.getAllAccessKeys();\n        const unknown = keys.filter((entity) => { var _a; return (_a = entity.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"unknown\"); });\n        return unknown;\n    }\n    isQualifiedEntity(entity) {\n        var _a, _b;\n        return (!((_a = entity.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"retired\")) &&\n            !((_b = entity.metadata.tags) === null || _b === void 0 ? void 0 : _b.includes(\"allow-unknown\")));\n    }\n    isEntity(entity) {\n        return entity !== undefined;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as core from \"@actions/core\";\nimport { client, v2 } from \"@datadog/datadog-api-client\";\nimport { MultisigsCollector } from \"../core/multisigs-collector\";\nimport { getBackstageEntities } from \"../utils/get-backstage-entities\";\nconst configuration = client.createConfiguration();\nconfiguration.setServerVariables({ site: \"datadoghq.eu\" });\nconst apiInstance = new v2.MetricsApi(configuration);\nconst DATADOG_GAUGE_TYPE = 3;\nconst SIGNER_POLICY_LIMIT_MS = 180 * 86400 * 1000; // amount of days * seconds in day * milliseconds in second\nexport class BackstageMetrics {\n}\nexport function backstageMetrics({ backstage_url, testing, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!backstage_url)\n            return;\n        const entities = yield getBackstageEntities({ backstage_url });\n        const multisigsCollector = new MultisigsCollector(entities);\n        try {\n            const multisigSeries = generateMultisigMetrics(multisigsCollector, backstage_url);\n            const signerSeries = generateSignerMetrics(multisigsCollector, backstage_url);\n            const keySeries = generateAccessKeyMetrics(multisigsCollector, backstage_url);\n            const keyCountByOwnerSeries = generateUserAccessKeyMetrics(multisigsCollector, backstage_url);\n            const keyCountByContractSeries = generateContractAccessKeyMetrics(multisigsCollector, backstage_url);\n            const deprecatedKeysSeries = generateDeprecatedAccessKeyMetrics(multisigsCollector, backstage_url);\n            const unknownAccessKeysSeries = generateUnknownAccessKeyMetrics(multisigsCollector, backstage_url);\n            const unknownSignerSeries = generateUnknownSignerMetrics(multisigsCollector, backstage_url);\n            const unknownAddressSeries = generateUnknownAddressMetrics(multisigsCollector, backstage_url);\n            const inactiveSignerSeries = generateInactiveSignerMetrics(multisigsCollector, backstage_url);\n            // const unverifiedContractSeries = generateUnverifiedContractsMetrics(multisigsCollector, backstage_url);\n            if (testing) {\n                return [];\n            }\n            const data = yield Promise.all([\n                submitMetrics(multisigSeries),\n                submitMetrics(signerSeries),\n                submitMetrics(keySeries),\n                submitMetrics(keyCountByOwnerSeries),\n                submitMetrics(keyCountByContractSeries),\n                submitMetrics(deprecatedKeysSeries),\n                submitMetrics(unknownAccessKeysSeries),\n                submitMetrics(unknownSignerSeries),\n                submitMetrics(unknownAddressSeries),\n                submitMetrics(inactiveSignerSeries),\n                // submitMetrics(unverifiedContractSeries)\n            ]);\n            core.info(`API called successfully. Returned data: ${JSON.stringify(data)}`);\n            return data;\n        }\n        catch (error) {\n            core.error(error);\n        }\n    });\n}\nfunction submitMetrics(series) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const params = {\n            body: {\n                series,\n            },\n        };\n        core.info(`Data to upload: ${JSON.stringify(params)}`);\n        return apiInstance.submitMetrics(params);\n    });\n}\nfunction generateMultisigMetrics(collector, backstageUrl) {\n    const series = collector.getMultisigs().map((multisig) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = multisig.entity;\n        const { name } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(multisig.entity.spec));\n        const { address, network, networkType, system: rawSystem, owner: rawOwner, } = spec;\n        const system = rawSystem.split(\":\")[1];\n        const owner = rawOwner.split(\":\")[1];\n        const timestamp = Math.round(new Date(spec.multisig.fetchDate).getTime() / 1000);\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"api\", name },\n            { type: \"address\", name: address },\n            { type: \"kind\", name: kind },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"system\", name: system },\n            { type: \"owner\", name: owner },\n        ];\n        const { version } = spec.multisig;\n        // datadog requires point value to be scalar\n        const value = parseFloat(version);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.multisigs.version\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateSignerMetrics(collector, backstageUrl) {\n    const series = collector.getSigners().map((signer) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = signer.signer;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar, 0 means unknown ownership\n        const value = namespace === \"stub\" ? 0 : 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.signers\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateUnknownSignerMetrics(collector, backstageUrl) {\n    const unknownSigners = collector\n        .getSigners()\n        .filter((entry) => {\n        var _a;\n        return ((_a = entry.signer.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"stub\")) ||\n            entry.signer.metadata.namespace === \"stub\";\n    });\n    const series = unknownSigners.map((signer) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = signer.signer;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar, 0 means unknown ownership\n        const value = 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.signers.unknown\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction generateUnverifiedContractsMetrics(collector, backstageUrl) {\n    const unverifiedContracts = collector\n        .getAllApis()\n        .filter((entity) => { var _a; return (_a = entity.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"unverified\"); });\n    const series = unverifiedContracts.map((entity) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = entity;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(entity.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar, 0 means unknown ownership\n        const value = 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.reports.unverified=contracts\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateUnknownAddressMetrics(collector, backstageUrl) {\n    const stubAndStateEntities = collector\n        .getAllResources()\n        .filter((entry) => {\n        var _a, _b;\n        return ((_a = entry.metadata.tags) === null || _a === void 0 ? void 0 : _a.includes(\"stub\")) &&\n            ((_b = entry.metadata.tags) === null || _b === void 0 ? void 0 : _b.includes(\"contract-state\"));\n    });\n    const series = stubAndStateEntities.map((entity) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = entity;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(entity.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar, 0 means unknown ownership\n        const value = 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.reports.unknown-addresses\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateAccessKeyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getMultisigAccessKeys()\n        .map((key) => {\n        // entities are typically emitted as Resource kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = key;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(key.spec));\n        const { owner: rawOwner } = spec;\n        const [ownerKind, ownerRef] = rawOwner.split(\":\");\n        const ownerName = ownerRef.split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"owner\", name: ownerName },\n            { type: \"ownerKind\", name: ownerKind },\n        ];\n        const value = namespace === \"stub\" || ownerKind !== \"user\" ? 0 : 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.access_keys\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateDeprecatedAccessKeyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getDeprecatedAccessKeys()\n        .map((key) => {\n        // entities are typically emitted as Resource kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = key;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(key.spec));\n        const { owner: rawOwner } = spec;\n        const [ownerKind, ownerRef] = rawOwner.split(\":\");\n        const ownerName = ownerRef.split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"owner\", name: ownerName },\n            { type: \"ownerKind\", name: ownerKind },\n        ];\n        const value = ownerKind !== \"user\" ? 0 : 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.access_keys.deprecated\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateUnknownAccessKeyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getUnknownAccessKeys()\n        .map((key) => {\n        // entities are typically emitted as Resource kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = key;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(key.spec));\n        const { owner: rawOwner } = spec;\n        const [ownerKind, ownerRef] = rawOwner.split(\":\");\n        const ownerName = ownerRef.split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"owner\", name: ownerName },\n            { type: \"ownerKind\", name: ownerKind },\n        ];\n        const value = 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.access_keys.unknown\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateUserAccessKeyMetrics(collector, backstageUrl) {\n    const series = Object.entries(collector.getAccessKeysPerSigner()).map(([signer, entry]) => {\n        const spec = JSON.parse(JSON.stringify(entry.signer.spec));\n        const { owner } = spec;\n        const ownerName = `${owner}/${signer}`;\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"owner\", name: ownerName },\n            { type: \"user\", name: owner },\n            { type: \"signer\", name: signer },\n        ];\n        const value = entry.keys.length;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.access_keys_owned_count\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateContractAccessKeyMetrics(collector, backstageUrl) {\n    const accessKeysPerContract = collector\n        .getContractAccessKeys()\n        .reduce((acc, key) => {\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(key.spec));\n        const { owner } = spec;\n        return Object.assign(Object.assign({}, acc), { [owner]: [...(acc[owner] || []), key] });\n    }, {});\n    const series = Object.entries(accessKeysPerContract).map(([owner, keys]) => {\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"owner\", name: owner },\n        ];\n        const value = keys.length;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.access_keys_by_contract_count\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateInactiveSignerMetrics(collector, backstageUrl) {\n    const series = collector.getSigners().map((entity) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = entity.signer;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(entity.signer.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        const now = new Date().getTime();\n        const isPastThreshold = now - Number(spec.lastSigned) > SIGNER_POLICY_LIMIT_MS;\n        const value = isPastThreshold ? 1 : 0;\n        const points = [{ timestamp: now, value }];\n        return {\n            metric: \"backstage.signers.inactive\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as core from \"@actions/core\";\nimport { CatalogClient } from \"@backstage/catalog-client\";\nimport { simpleGit } from \"simple-git\";\nfunction getFileContentFromRepo(repoUrl, filePath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const cloneDir = `/tmp/github-helpers-${Date.now()}`;\n        const git = simpleGit();\n        try {\n            yield git.clone(repoUrl, cloneDir, [\"--depth=1\"]);\n            yield git.cwd(cloneDir);\n            const { current } = yield git.branch();\n            const defaultBranch = current || \"main\";\n            const fileContent = yield git.show([\n                `${defaultBranch}:${filePath}`,\n            ]);\n            yield git.raw([\"rm\", \"-rf\", \".\"]);\n            return fileContent;\n        }\n        catch (error) {\n            throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n        }\n    });\n}\nfunction fetchBackstageEntitiesFromURL(backstageUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n        core.info(\"Connecting to Backstage to fetch available entities\");\n        const discoveryApi = {\n            getBaseUrl() {\n                return __awaiter(this, void 0, void 0, function* () {\n                    return `${backstageUrl}/api/catalog`;\n                });\n            },\n        };\n        const catalogClient = new CatalogClient({\n            discoveryApi,\n        });\n        const entities = yield catalogClient.getEntities({});\n        core.info(`Total backstage entities: ${entities.items.length}`);\n        return entities.items;\n    });\n}\nfunction fetchBackstageEntitiesFromRepo(backstageEntitiesRepo) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const serverUrl = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n        const repoUrl = `${serverUrl}/${backstageEntitiesRepo}`;\n        core.info(`Cloning ${repoUrl}`);\n        const content = yield getFileContentFromRepo(repoUrl, \"filteredEntities.json\");\n        return JSON.parse(content);\n    });\n}\nexport const getBackstageEntities = ({ backstage_url: backstageUrl, backstage_entities_repo: backstageEntitiesRepo, }) => __awaiter(void 0, void 0, void 0, function* () {\n    // repo takes a priority over the URL in order to avoid unnecessary runtime\n    // dependency\n    if (backstageEntitiesRepo) {\n        return fetchBackstageEntitiesFromRepo(backstageEntitiesRepo);\n    }\n    else if (backstageUrl) {\n        return fetchBackstageEntitiesFromURL(backstageUrl);\n    }\n    throw new Error(\"Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action\");\n});\n"],"names":[],"sourceRoot":""}