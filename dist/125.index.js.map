{"version":3,"file":"125.index.js","mappings":";;;;;;;;;;;;AAAA;AAqCA;AASA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxSA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;;AAIA;AAAA;AACA;AAEA;AAEA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7kBA;AACA;AAEA;AAOA;;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AAEA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA","sources":["webpack://backstage-blockchain-actions/./src/core/multisigs-collector.ts","webpack://backstage-blockchain-actions/./src/helpers/backstage-metrics.ts","webpack://backstage-blockchain-actions/./src/utils/get-backstage-entities.ts"],"sourcesContent":["import {\n  isApiEntity,\n  isResourceEntity,\n  stringifyEntityRef,\n  RELATION_OWNED_BY,\n  RELATION_API_CONSUMED_BY,\n  RELATION_HAS_PART,\n  parseEntityRef,\n} from \"@backstage/catalog-model\";\nimport type { Entity } from \"@backstage/catalog-model\";\n\ntype MultisigSigner = {\n  signer: Entity;\n  owner?: Entity;\n};\ntype MultisigSignerAndKeysComposed = MultisigSigner & { keys: Entity[] };\ntype MultisigSignerAndKeys = {\n  [K in keyof MultisigSignerAndKeysComposed]: MultisigSignerAndKeysComposed[K];\n};\n\ntype MultisigInfo = {\n  entity: Entity;\n  signers: MultisigSigner[];\n};\n\ntype ComponentMultisigs = {\n  title: string;\n  component: Entity;\n  multisigs: MultisigInfo[];\n};\n\ntype SystemComponents = {\n  title: string;\n  system: Entity;\n  components: ComponentMultisigs[];\n};\n\nexport class MultisigsCollector {\n  systemComponents: SystemComponents[] = [];\n  private entities: Entity[] = [];\n  private apiEntities: Entity[] = [];\n  private resourceEntities: Entity[] = [];\n  private multisigs: Entity[] = [];\n  private contracts: Entity[] = [];\n  private accessKeys: Entity[] = [];\n\n  constructor(entities: Entity[]) {\n    this.entities = entities;\n    this.apiEntities = this.entities.filter(isApiEntity);\n    this.resourceEntities = this.entities.filter(isResourceEntity);\n    this.multisigs = this.apiEntities.filter(\n      (item) => item.spec?.type === \"multisig-deployment\",\n    );\n    this.contracts = this.apiEntities.filter(\n      (item) => item.spec?.type === \"contract-deployment\",\n    );\n    this.accessKeys = this.resourceEntities.filter(\n      (item) => item.spec?.type === \"access-key\",\n    );\n    this.systemComponents = this.collectSystems();\n  }\n\n  normalizeEntities(list: string[]) {\n    return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n  }\n\n  collectSystems() {\n    const systemRefs = this.normalizeEntities(\n      this.multisigs.map((item) => item.spec!.system! as string),\n    );\n    return systemRefs\n      .map((systemRef) => {\n        const system = this.entities.find(\n          (item) => stringifyEntityRef(item) === systemRef,\n        )!;\n        const components = this.collectComponents(system);\n\n        return {\n          title: system.metadata.title || system.metadata.name,\n          system,\n          components,\n        };\n      })\n      .sort((a, b) =>\n        a.system.metadata.name.localeCompare(b.system.metadata.name),\n      );\n  }\n\n  collectComponents(system: Entity) {\n    const componentRefs = system.relations!.filter(\n      (r) =>\n        r.type === RELATION_HAS_PART &&\n        parseEntityRef(r.targetRef).kind === \"component\",\n    );\n    return componentRefs\n      .map((componentRef) => {\n        const component = this.entities.find(\n          (item) => stringifyEntityRef(item) === componentRef.targetRef,\n        )!;\n        return {\n          title: component.metadata.title || component.metadata.name,\n          component,\n          multisigs: this.multisigs\n            .filter((item) =>\n              item.relations!.some(\n                (r) =>\n                  r.type === \"apiProvidedBy\" &&\n                  r.targetRef === componentRef.targetRef,\n              ),\n            )\n            .map((ms) => ({\n              entity: ms,\n              signers: this.collectSigners(ms),\n            })),\n        };\n      })\n      .sort((a, b) =>\n        a.component.metadata.name.localeCompare(b.component.metadata.name),\n      );\n  }\n\n  collectSigners(multisig: Entity) {\n    return multisig\n      .relations!.filter(\n        (r) =>\n          r.type === RELATION_OWNED_BY &&\n          parseEntityRef(r.targetRef).kind !== \"group\",\n      )\n      .map((r) => {\n        const signer = this.entities.find(\n          (e) => stringifyEntityRef(e) === r.targetRef,\n        )!;\n        const owner = this.entities.find(\n          (e) => stringifyEntityRef(e) === signer.spec!.owner,\n        )!;\n        return {\n          signer,\n          owner,\n        };\n      })\n      .sort((a, b) =>\n        a.owner.metadata.name.localeCompare(b.owner.metadata.name),\n      );\n  }\n\n  getAllApis() {\n    return this.apiEntities;\n  }\n\n  getAllResources() {\n    return this.resourceEntities;\n  }\n\n  getMultisigs() {\n    return this.systemComponents.flatMap((system) =>\n      system.components.flatMap((component) => component.multisigs),\n    );\n  }\n\n  getNearContracts() {\n    return this.contracts.filter((entity) => entity.spec?.network === \"near\");\n  }\n\n  getSigners() {\n    const allSigners = this.getMultisigs().flatMap((ms) => ms.signers);\n    const uniqueSigners = allSigners.reduce<{ [uid: string]: MultisigSigner }>(\n      (acc, signer) => {\n        const uid = signer.signer.metadata.uid;\n        if (uid && uid in allSigners) {\n          return acc;\n        }\n        if (!this.isQualifiedEntity(signer.signer)) {\n          return acc;\n        }\n        return { ...acc, [uid as string]: signer };\n      },\n      {},\n    );\n    return Object.values(uniqueSigners);\n  }\n\n  getMultisigAccessKeys(): Entity[] {\n    const signers = this.getSigners().filter(\n      (value) => value.signer.spec?.network === \"near\",\n    );\n    const keys = signers.flatMap((value) => {\n      if (!value.signer.relations) {\n        return [];\n      }\n      return value.signer.relations\n        .filter(\n          (r) =>\n            r.type === RELATION_API_CONSUMED_BY &&\n            parseEntityRef(r.targetRef).kind === \"resource\",\n        )\n        .map((relation) => {\n          const key = this.entities.find(\n            (e) => stringifyEntityRef(e) === relation.targetRef,\n          );\n          return key;\n        });\n    });\n\n    return keys.filter<Entity>(this.isEntity).filter(this.isQualifiedEntity);\n  }\n\n  getAccessKeysPerSigner() {\n    const signers = this.getSigners().filter(\n      (value) => value.signer.spec?.network === \"near\",\n    );\n    const keysPerSigner = signers.reduce<{\n      [s: string]: MultisigSignerAndKeys;\n    }>((acc, value) => {\n      if (!value.signer.relations) {\n        return acc;\n      }\n      const spec = JSON.parse(JSON.stringify(value.signer.spec));\n      const signer: string = spec.address;\n      const keys = value.signer.relations\n        .filter(\n          (r) =>\n            r.type === RELATION_API_CONSUMED_BY &&\n            parseEntityRef(r.targetRef).kind === \"resource\",\n        )\n        .map((relation) => {\n          const key = this.entities.find(\n            (e) => stringifyEntityRef(e) === relation.targetRef,\n          );\n          return key;\n        })\n        .filter<Entity>(this.isEntity);\n\n      return {\n        ...acc,\n        [signer]: {\n          owner: value.owner,\n          signer: value.signer,\n          keys,\n        },\n      };\n    }, {});\n\n    return keysPerSigner;\n  }\n\n  getContractAccessKeys(): Entity[] {\n    const keys = this.contracts.flatMap((value) => {\n      if (!value.relations) {\n        return [];\n      }\n      return value.relations\n        .filter(\n          (r) =>\n            r.type === RELATION_API_CONSUMED_BY &&\n            parseEntityRef(r.targetRef).kind === \"resource\",\n        )\n        .map((relation) => {\n          const key = this.entities.find(\n            (e) => stringifyEntityRef(e) === relation.targetRef,\n          );\n          return key;\n        });\n    });\n    return keys.filter<Entity>(this.isEntity);\n  }\n\n  getAllAccessKeys(): Entity[] {\n    return this.accessKeys;\n  }\n\n  getDeprecatedAccessKeys(): Entity[] {\n    const keys = this.getAllAccessKeys();\n    const deprecated = keys.filter(\n      (entity) => entity.metadata.tags?.includes(\"deprecated\"),\n    );\n    return deprecated;\n  }\n\n  getUnknownAccessKeys(): Entity[] {\n    const keys = this.getAllAccessKeys();\n    const unknown = keys.filter(\n      (entity) => entity.metadata.tags?.includes(\"unknown\"),\n    );\n    return unknown;\n  }\n\n  private isQualifiedEntity(entity: Entity) {\n    return (\n      !entity.metadata.tags?.includes(\"retired\") &&\n      !entity.metadata.tags?.includes(\"allow-unknown\")\n    );\n  }\n\n  private isEntity(entity: Entity | undefined): entity is Entity {\n    return entity !== undefined;\n  }\n}\n","import * as core from \"@actions/core\";\nimport { client, v2 } from \"@datadog/datadog-api-client\";\nimport type { Entity } from \"@backstage/catalog-model\";\n\nimport { MultisigsCollector } from \"../core/multisigs-collector\";\nimport { getBackstageEntities } from \"../utils/get-backstage-entities\";\n\nconst configuration = client.createConfiguration();\nconfiguration.setServerVariables({ site: \"datadoghq.eu\" });\n\nconst apiInstance = new v2.MetricsApi(configuration);\nconst DATADOG_GAUGE_TYPE = 3;\nconst SIGNER_POLICY_LIMIT_MS = 180 * 86400 * 1000; // amount of days * seconds in day * milliseconds in second\n\nexport class BackstageMetrics {\n  backstage_url?: string;\n  testing?: boolean;\n}\n\nexport async function backstageMetrics({\n  backstage_url,\n  testing,\n}: BackstageMetrics) {\n  if (!backstage_url) return;\n  const entities = await getBackstageEntities({ backstage_url });\n\n  const multisigsCollector = new MultisigsCollector(entities);\n\n  try {\n    const multisigSeries = generateMultisigMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const signerSeries = generateSignerMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const keySeries = generateAccessKeyMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const keyCountByOwnerSeries = generateUserAccessKeyMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const keyCountByContractSeries = generateContractAccessKeyMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const deprecatedKeysSeries = generateDeprecatedAccessKeyMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const unknownAccessKeysSeries = generateUnknownAccessKeyMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const unknownSignerSeries = generateUnknownSignerMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const unknownAddressSeries = generateUnknownAddressMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    const inactiveSignerSeries = generateInactiveSignerMetrics(\n      multisigsCollector,\n      backstage_url,\n    );\n    // const unverifiedContractSeries = generateUnverifiedContractsMetrics(multisigsCollector, backstage_url);\n    if (testing) {\n      return [];\n    }\n    const data = await Promise.all([\n      submitMetrics(multisigSeries),\n      submitMetrics(signerSeries),\n      submitMetrics(keySeries),\n      submitMetrics(keyCountByOwnerSeries),\n      submitMetrics(keyCountByContractSeries),\n      submitMetrics(deprecatedKeysSeries),\n      submitMetrics(unknownAccessKeysSeries),\n      submitMetrics(unknownSignerSeries),\n      submitMetrics(unknownAddressSeries),\n      submitMetrics(inactiveSignerSeries),\n      // submitMetrics(unverifiedContractSeries)\n    ]);\n\n    core.info(\n      `API called successfully. Returned data: ${JSON.stringify(data)}`,\n    );\n    return data;\n  } catch (error: unknown) {\n    core.error(error as Error);\n  }\n}\n\nasync function submitMetrics(series: v2.MetricSeries[]) {\n  const params = {\n    body: {\n      series,\n    },\n  };\n  core.info(`Data to upload: ${JSON.stringify(params)}`);\n\n  return apiInstance.submitMetrics(params);\n}\n\nfunction generateMultisigMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const series = collector.getMultisigs().map<v2.MetricSeries>((multisig) => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = multisig.entity;\n    const { name } = metadata;\n\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(multisig.entity.spec));\n    const {\n      address,\n      network,\n      networkType,\n      system: rawSystem,\n      owner: rawOwner,\n    } = spec;\n    const system = rawSystem.split(\":\")[1];\n    const owner = rawOwner.split(\":\")[1];\n    const timestamp = Math.round(\n      new Date(spec.multisig.fetchDate).getTime() / 1000,\n    );\n\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: \"host\",\n        name: backstageUrl.split(\"@\")[1],\n      },\n      { type: \"api\", name },\n      { type: \"address\", name: address },\n      { type: \"kind\", name: kind },\n      { type: \"network\", name: network },\n      { type: \"networkType\", name: networkType },\n      { type: \"system\", name: system },\n      { type: \"owner\", name: owner },\n    ];\n\n    const { version } = spec.multisig;\n    // datadog requires point value to be scalar\n    const value = parseFloat(version);\n    const points = [{ timestamp, value }];\n    return {\n      metric: \"backstage.multisigs.version\",\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources,\n    };\n  });\n  return series;\n}\n\nfunction generateSignerMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const series = collector.getSigners().map<v2.MetricSeries>((signer) => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = signer.signer;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: \"host\",\n        name: backstageUrl.split(\"@\")[1],\n      },\n      { type: \"kind\", name: kind },\n      { type: \"name\", name },\n      { type: \"namespace\", name: namespace },\n      { type: \"address\", name: address },\n      { type: \"network\", name: network },\n      { type: \"networkType\", name: networkType },\n      { type: \"owner\", name: owner },\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = namespace === \"stub\" ? 0 : 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: \"backstage.signers\",\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources,\n    };\n  });\n  return series;\n}\n\nfunction generateUnknownSignerMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const unknownSigners = collector\n    .getSigners()\n    .filter(\n      (entry) =>\n        entry.signer.metadata.tags?.includes(\"stub\") ||\n        entry.signer.metadata.namespace === \"stub\",\n    );\n  const series = unknownSigners.map<v2.MetricSeries>((signer) => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = signer.signer;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: \"host\",\n        name: backstageUrl.split(\"@\")[1],\n      },\n      { type: \"kind\", name: kind },\n      { type: \"name\", name },\n      { type: \"namespace\", name: namespace },\n      { type: \"address\", name: address },\n      { type: \"network\", name: network },\n      { type: \"networkType\", name: networkType },\n      { type: \"owner\", name: owner },\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: \"backstage.signers.unknown\",\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources,\n    };\n  });\n  return series;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction generateUnverifiedContractsMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const unverifiedContracts = collector\n    .getAllApis()\n    .filter((entity) => entity.metadata.tags?.includes(\"unverified\"));\n  const series = unverifiedContracts.map<v2.MetricSeries>((entity) => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = entity;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(entity.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: \"host\",\n        name: backstageUrl.split(\"@\")[1],\n      },\n      { type: \"kind\", name: kind },\n      { type: \"name\", name },\n      { type: \"namespace\", name: namespace },\n      { type: \"address\", name: address },\n      { type: \"network\", name: network },\n      { type: \"networkType\", name: networkType },\n      { type: \"owner\", name: owner },\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: \"backstage.reports.unverified=contracts\",\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources,\n    };\n  });\n  return series;\n}\n\nfunction generateUnknownAddressMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const stubAndStateEntities = collector\n    .getAllResources()\n    .filter(\n      (entry) =>\n        entry.metadata.tags?.includes(\"stub\") &&\n        entry.metadata.tags?.includes(\"contract-state\"),\n    );\n  const series = stubAndStateEntities.map<v2.MetricSeries>((entity) => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = entity;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(entity.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: \"host\",\n        name: backstageUrl.split(\"@\")[1],\n      },\n      { type: \"kind\", name: kind },\n      { type: \"name\", name },\n      { type: \"namespace\", name: namespace },\n      { type: \"address\", name: address },\n      { type: \"network\", name: network },\n      { type: \"networkType\", name: networkType },\n      { type: \"owner\", name: owner },\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: \"backstage.reports.unknown-addresses\",\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources,\n    };\n  });\n  return series;\n}\n\nfunction generateAccessKeyMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const series = collector\n    .getMultisigAccessKeys()\n    .map<v2.MetricSeries>((key) => {\n      // entities are typically emitted as Resource kind,\n      // tracking for inconsistencies\n      const { kind, metadata } = key;\n      const { name, namespace } = metadata;\n      // inferred type is JsonObject, this converts to any\n      const spec = JSON.parse(JSON.stringify(key.spec));\n      const { owner: rawOwner } = spec;\n      const [ownerKind, ownerRef] = rawOwner.split(\":\");\n      const ownerName = ownerRef.split(\"/\")[1];\n      // this tags timeseries with distinguishing\n      // properties for filtering purposes\n      const resources = [\n        {\n          type: \"host\",\n          name: backstageUrl.split(\"@\")[1],\n        },\n        { type: \"kind\", name: kind },\n        { type: \"name\", name },\n        { type: \"namespace\", name: namespace },\n        { type: \"owner\", name: ownerName },\n        { type: \"ownerKind\", name: ownerKind },\n      ];\n      const value = namespace === \"stub\" || ownerKind !== \"user\" ? 0 : 1;\n      const timestamp = Math.round(new Date().getTime() / 1000);\n      const points = [{ timestamp, value }];\n      return {\n        metric: \"backstage.access_keys\",\n        type: DATADOG_GAUGE_TYPE,\n        points,\n        resources,\n      };\n    });\n  return series;\n}\n\nfunction generateDeprecatedAccessKeyMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const series = collector\n    .getDeprecatedAccessKeys()\n    .map<v2.MetricSeries>((key) => {\n      // entities are typically emitted as Resource kind,\n      // tracking for inconsistencies\n      const { kind, metadata } = key;\n      const { name, namespace } = metadata;\n      // inferred type is JsonObject, this converts to any\n      const spec = JSON.parse(JSON.stringify(key.spec));\n      const { owner: rawOwner } = spec;\n      const [ownerKind, ownerRef] = rawOwner.split(\":\");\n      const ownerName = ownerRef.split(\"/\")[1];\n      // this tags timeseries with distinguishing\n      // properties for filtering purposes\n      const resources = [\n        {\n          type: \"host\",\n          name: backstageUrl.split(\"@\")[1],\n        },\n        { type: \"kind\", name: kind },\n        { type: \"name\", name },\n        { type: \"namespace\", name: namespace },\n        { type: \"owner\", name: ownerName },\n        { type: \"ownerKind\", name: ownerKind },\n      ];\n      const value = ownerKind !== \"user\" ? 0 : 1;\n      const timestamp = Math.round(new Date().getTime() / 1000);\n      const points = [{ timestamp, value }];\n      return {\n        metric: \"backstage.access_keys.deprecated\",\n        type: DATADOG_GAUGE_TYPE,\n        points,\n        resources,\n      };\n    });\n  return series;\n}\n\nfunction generateUnknownAccessKeyMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const series = collector\n    .getUnknownAccessKeys()\n    .map<v2.MetricSeries>((key) => {\n      // entities are typically emitted as Resource kind,\n      // tracking for inconsistencies\n      const { kind, metadata } = key;\n      const { name, namespace } = metadata;\n      // inferred type is JsonObject, this converts to any\n      const spec = JSON.parse(JSON.stringify(key.spec));\n      const { owner: rawOwner } = spec;\n      const [ownerKind, ownerRef] = rawOwner.split(\":\");\n      const ownerName = ownerRef.split(\"/\")[1];\n      // this tags timeseries with distinguishing\n      // properties for filtering purposes\n      const resources = [\n        {\n          type: \"host\",\n          name: backstageUrl.split(\"@\")[1],\n        },\n        { type: \"kind\", name: kind },\n        { type: \"name\", name },\n        { type: \"namespace\", name: namespace },\n        { type: \"owner\", name: ownerName },\n        { type: \"ownerKind\", name: ownerKind },\n      ];\n      const value = 1;\n      const timestamp = Math.round(new Date().getTime() / 1000);\n      const points = [{ timestamp, value }];\n      return {\n        metric: \"backstage.access_keys.unknown\",\n        type: DATADOG_GAUGE_TYPE,\n        points,\n        resources,\n      };\n    });\n  return series;\n}\n\nfunction generateUserAccessKeyMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const series = Object.entries(\n    collector.getAccessKeysPerSigner(),\n  ).map<v2.MetricSeries>(([signer, entry]) => {\n    const spec = JSON.parse(JSON.stringify(entry.signer.spec));\n    const { owner } = spec;\n    const ownerName = `${owner}/${signer}`;\n    const resources = [\n      {\n        type: \"host\",\n        name: backstageUrl.split(\"@\")[1],\n      },\n      { type: \"owner\", name: ownerName },\n      { type: \"user\", name: owner },\n      { type: \"signer\", name: signer },\n    ];\n    const value = entry.keys.length;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: \"backstage.access_keys_owned_count\",\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources,\n    };\n  });\n  return series;\n}\n\ntype KeysByOwner = {\n  [owner: string]: Entity[];\n};\n\nfunction generateContractAccessKeyMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const accessKeysPerContract = collector\n    .getContractAccessKeys()\n    .reduce<KeysByOwner>((acc, key) => {\n      // inferred type is JsonObject, this converts to any\n      const spec = JSON.parse(JSON.stringify(key.spec));\n      const { owner } = spec;\n      return {\n        ...acc,\n        [owner]: [...(acc[owner] || []), key],\n      };\n    }, {});\n  const series = Object.entries(accessKeysPerContract).map<v2.MetricSeries>(\n    ([owner, keys]) => {\n      const resources = [\n        {\n          type: \"host\",\n          name: backstageUrl.split(\"@\")[1],\n        },\n        { type: \"owner\", name: owner },\n      ];\n      const value = keys.length;\n      const timestamp = Math.round(new Date().getTime() / 1000);\n      const points = [{ timestamp, value }];\n      return {\n        metric: \"backstage.access_keys_by_contract_count\",\n        type: DATADOG_GAUGE_TYPE,\n        points,\n        resources,\n      };\n    },\n  );\n  return series;\n}\n\nfunction generateInactiveSignerMetrics(\n  collector: MultisigsCollector,\n  backstageUrl: string,\n) {\n  const series = collector.getSigners().map<v2.MetricSeries>((entity) => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = entity.signer;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(entity.signer.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: \"host\",\n        name: backstageUrl.split(\"@\")[1],\n      },\n      { type: \"kind\", name: kind },\n      { type: \"name\", name },\n      { type: \"namespace\", name: namespace },\n      { type: \"address\", name: address },\n      { type: \"network\", name: network },\n      { type: \"networkType\", name: networkType },\n      { type: \"owner\", name: owner },\n    ];\n    const now = new Date().getTime();\n    const isPastThreshold =\n      now - Number(spec.lastSigned) > SIGNER_POLICY_LIMIT_MS;\n    const value = isPastThreshold ? 1 : 0;\n    const points = [{ timestamp: now, value }];\n    return {\n      metric: \"backstage.signers.inactive\",\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources,\n    };\n  });\n  return series;\n}\n","import * as core from \"@actions/core\";\nimport { CatalogClient } from \"@backstage/catalog-client\";\nimport type { Entity } from \"@backstage/catalog-model\";\nimport { simpleGit } from \"simple-git\";\n\ninterface GetBackstageEntities {\n  backstage_url?: string;\n  backstage_entities_repo?: string;\n}\n\nasync function getFileContentFromRepo(\n  repoUrl: string,\n  filePath: string,\n): Promise<string> {\n  const cloneDir = `/tmp/github-helpers-${Date.now()}`;\n  const git = simpleGit();\n\n  try {\n    await git.clone(repoUrl, cloneDir, [\"--depth=1\"]);\n    await git.cwd(cloneDir);\n\n    const { current } = await git.branch();\n    const defaultBranch = current || \"main\";\n    const fileContent: string = await git.show([\n      `${defaultBranch}:${filePath}`,\n    ]);\n\n    await git.raw([\"rm\", \"-rf\", \".\"]);\n    return fileContent;\n  } catch (error) {\n    throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n  }\n}\n\nasync function fetchBackstageEntitiesFromURL(backstageUrl: string) {\n  core.info(\"Connecting to Backstage to fetch available entities\");\n\n  const discoveryApi = {\n    async getBaseUrl() {\n      return `${backstageUrl}/api/catalog`;\n    },\n  };\n  const catalogClient = new CatalogClient({\n    discoveryApi,\n  });\n\n  const entities = await catalogClient.getEntities({});\n  core.info(`Total backstage entities: ${entities.items.length}`);\n\n  return entities.items;\n}\n\nasync function fetchBackstageEntitiesFromRepo(backstageEntitiesRepo: string) {\n  const serverUrl = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n  const repoUrl = `${serverUrl}/${backstageEntitiesRepo}`;\n  core.info(`Cloning ${repoUrl}`);\n  const content = await getFileContentFromRepo(\n    repoUrl,\n    \"filteredEntities.json\",\n  );\n  return JSON.parse(content) as Entity[];\n}\n\nexport const getBackstageEntities = async ({\n  backstage_url: backstageUrl,\n  backstage_entities_repo: backstageEntitiesRepo,\n}: GetBackstageEntities) => {\n  // repo takes a priority over the URL in order to avoid unnecessary runtime\n  // dependency\n  if (backstageEntitiesRepo) {\n    return fetchBackstageEntitiesFromRepo(backstageEntitiesRepo);\n  } else if (backstageUrl) {\n    return fetchBackstageEntitiesFromURL(backstageUrl);\n  }\n  throw new Error(\n    \"Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action\",\n  );\n};\n"],"names":[],"sourceRoot":""}