{"version":3,"file":"125.index.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACliBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://backstage-blockchain-actions/./src/core/base-collector.ts","webpack://backstage-blockchain-actions/./src/core/metrics-collector.ts","webpack://backstage-blockchain-actions/./src/core/multisigs-collector.ts","webpack://backstage-blockchain-actions/./src/helpers/backstage-metrics.ts","webpack://backstage-blockchain-actions/./src/utils/get-backstage-entities.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseCollector = void 0;\nconst catalog_model_1 = require(\"@backstage/catalog-model\");\nclass BaseCollector {\n    constructor(entities) {\n        this.entities = [];\n        this.entityCatalog = {};\n        this.entities = entities;\n        this.entityCatalog = entities.reduce((acc, e) => ({ ...acc, [(0, catalog_model_1.stringifyEntityRef)(e)]: e }), {});\n    }\n    getSystemEntities() {\n        return this.entities.filter(catalog_model_1.isSystemEntity).sort(this.sortByName);\n    }\n    getApiEntities() {\n        return this.entities.filter(catalog_model_1.isApiEntity).sort(this.sortByName);\n    }\n    getResourceEntities() {\n        return this.entities.filter(catalog_model_1.isResourceEntity).sort(this.sortByName);\n    }\n    getUserEntities() {\n        return this.entities.filter(catalog_model_1.isUserEntity).sort(this.sortByName);\n    }\n    getEntityTags(entity) {\n        return entity.metadata.tags || [];\n    }\n    sortByName(a, b) {\n        return a.metadata.name.localeCompare(b.metadata.name);\n    }\n}\nexports.BaseCollector = BaseCollector;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MetricsCollector = void 0;\nconst catalog_model_1 = require(\"@backstage/catalog-model\");\nconst backstage_plugin_blockchainradar_common_1 = require(\"@aurora-is-near/backstage-plugin-blockchainradar-common\");\nconst base_collector_1 = require(\"./base-collector\");\nconst multisigs_collector_1 = require(\"./multisigs-collector\");\nclass MetricsCollector extends base_collector_1.BaseCollector {\n    constructor(entities, opts = {}) {\n        super(entities);\n        this.multisigInfos = [];\n        this.apiEntities = [];\n        this.resourceEntities = [];\n        this.contracts = [];\n        this.accessKeys = [];\n        this.apiEntities = this.getApiEntities();\n        this.resourceEntities = this.getResourceEntities();\n        this.contracts = this.apiEntities.filter((item) => item.spec?.type === \"contract-deployment\");\n        this.accessKeys = this.resourceEntities.filter((item) => item.spec?.type === \"access-key\");\n        this.multisigInfos = new multisigs_collector_1.MultisigsCollector(entities)\n            .collectSystems(opts)\n            .flatMap((system) => system.components.flatMap((component) => component.multisigs))\n            .filter(this.isDefined);\n    }\n    getAllApis() {\n        return this.apiEntities;\n    }\n    getAllResources() {\n        return this.resourceEntities;\n    }\n    getMultisigs() {\n        return this.multisigInfos;\n    }\n    getNearContracts() {\n        return this.apiEntities\n            .filter(backstage_plugin_blockchainradar_common_1.isContractDeployment)\n            .filter((entity) => entity.spec?.network === \"near\");\n    }\n    getNearSigners() {\n        return this.resourceEntities\n            .filter(backstage_plugin_blockchainradar_common_1.isSigner)\n            .filter((entity) => entity.spec?.network === \"near\");\n    }\n    // to find signers that are part of a multisig council\n    getSigners() {\n        const allSigners = this.getMultisigs().flatMap((ms) => ms.signers);\n        const uniqueSigners = allSigners.reduce((acc, signer) => {\n            const uid = signer.signer.metadata.uid;\n            if (uid && uid in allSigners) {\n                return acc;\n            }\n            if (!this.isQualifiedEntity(signer.signer)) {\n                return acc;\n            }\n            return { ...acc, [uid]: signer };\n        }, {});\n        return Object.values(uniqueSigners);\n    }\n    getMultisigPolicies() {\n        const multisigs = this.getMultisigs();\n        const policies = multisigs.reduce((acc, { entity }) => {\n            if (!(0, backstage_plugin_blockchainradar_common_1.isMultisigDeployment)(entity) ||\n                !entity.spec.multisig ||\n                !entity.spec.multisig.policy) {\n                return acc;\n            }\n            return [\n                ...acc,\n                {\n                    entity,\n                    policy: entity.spec.multisig.policy.threshold /\n                        (entity.spec.multisig.policy.owners || 1),\n                },\n            ];\n        }, []);\n        return policies;\n    }\n    getMultisigAccessKeys() {\n        const signers = this.getSigners().filter((value) => value.signer.spec?.network === \"near\");\n        const keys = signers.flatMap((value) => {\n            if (!value.signer.relations) {\n                return [];\n            }\n            return value.signer.relations\n                .filter((r) => r.type === catalog_model_1.RELATION_API_CONSUMED_BY &&\n                (0, catalog_model_1.parseEntityRef)(r.targetRef).kind === \"resource\")\n                .map((relation) => {\n                const key = this.entityCatalog[relation.targetRef];\n                return key;\n            });\n        });\n        return keys.filter(this.isEntity).filter(this.isQualifiedEntity);\n    }\n    getAccessKeysPerSigner() {\n        const signers = this.getNearSigners();\n        const keysPerSigner = signers.reduce((acc, entity) => {\n            if (!entity.relations || entity.relations.length === 0) {\n                return acc;\n            }\n            return [\n                ...acc,\n                {\n                    entity,\n                    keys: entity.relations.reduce((accKeys, relation) => {\n                        const key = this.entityCatalog[relation.targetRef];\n                        if (relation.type !== catalog_model_1.RELATION_API_CONSUMED_BY ||\n                            !key ||\n                            !(0, backstage_plugin_blockchainradar_common_1.isAccessKey)(key)) {\n                            return accKeys;\n                        }\n                        return [...accKeys, key];\n                    }, []),\n                },\n            ];\n        }, []);\n        return keysPerSigner;\n    }\n    getAccessKeysPerContract() {\n        const contracts = this.getNearContracts();\n        const keysPerContract = contracts.reduce((acc, entity) => {\n            if (!entity.relations || entity.relations.length === 0) {\n                return acc;\n            }\n            const component = entity.relations.find((relation) => relation.type === catalog_model_1.RELATION_API_PROVIDED_BY);\n            return [\n                ...acc,\n                {\n                    entity,\n                    component: component?.targetRef,\n                    keys: entity.relations.reduce((accKeys, relation) => {\n                        const key = this.entityCatalog[relation.targetRef];\n                        if (relation.type !== catalog_model_1.RELATION_API_CONSUMED_BY ||\n                            !key ||\n                            !(0, backstage_plugin_blockchainradar_common_1.isAccessKey)(key)) {\n                            return accKeys;\n                        }\n                        return [...accKeys, key];\n                    }, []),\n                },\n            ];\n        }, []);\n        return keysPerContract;\n    }\n    getAllAccessKeys() {\n        return this.accessKeys;\n    }\n    getDeprecatedAccessKeys() {\n        const keys = this.getAllAccessKeys();\n        const deprecated = keys.filter((entity) => entity.metadata.tags?.includes(\"deprecated\"));\n        return deprecated;\n    }\n    getUnknownAccessKeys() {\n        const keys = this.getAllAccessKeys();\n        const unknown = keys.filter((entity) => entity.metadata.tags?.includes(\"unknown\"));\n        return unknown;\n    }\n    isQualifiedEntity(entity) {\n        return (!entity.metadata.tags?.includes(\"retired\") &&\n            !entity.metadata.tags?.includes(\"allow-unknown\"));\n    }\n    isEntity(entity) {\n        return entity !== undefined;\n    }\n    isDefined(entity) {\n        return entity !== undefined;\n    }\n}\nexports.MetricsCollector = MetricsCollector;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultisigsCollector = void 0;\nconst catalog_model_1 = require(\"@backstage/catalog-model\");\nconst base_collector_1 = require(\"./base-collector\");\nclass MultisigsCollector extends base_collector_1.BaseCollector {\n    collectSystems(opts) {\n        return this.getSystemEntities()\n            .reduce((acc, system) => {\n            if (opts.scope && system.spec?.owner !== opts.scope) {\n                return acc;\n            }\n            const components = this.collectComponents(system, opts);\n            if (components.some((c) => c.multisigs?.length)) {\n                return [\n                    ...acc,\n                    {\n                        title: system.metadata.title || system.metadata.name,\n                        system,\n                        components,\n                    },\n                ];\n            }\n            return acc;\n        }, [])\n            .sort((a, b) => this.sortByName(a.system, b.system));\n    }\n    collectComponents(system, opts = {}) {\n        const componentRefs = system.relations.filter((r) => r.type === catalog_model_1.RELATION_HAS_PART &&\n            (0, catalog_model_1.parseEntityRef)(r.targetRef).kind === \"component\");\n        return componentRefs\n            .reduce((acc, componentRef) => {\n            const component = this.entityCatalog[componentRef.targetRef];\n            if (opts.lifecycle && component.spec?.lifecycle !== opts.lifecycle) {\n                return acc;\n            }\n            const multisigs = this.collectMultisigs(componentRef);\n            if (multisigs.length) {\n                return [\n                    ...acc,\n                    {\n                        title: component.metadata.title || component.metadata.name,\n                        component,\n                        multisigs,\n                        tags: this.getEntityTags(component),\n                    },\n                ];\n            }\n            return acc;\n        }, [])\n            .sort((a, b) => this.sortByName(a.component, b.component));\n    }\n    collectMultisigs(componentRef) {\n        return this.getApiEntities()\n            .filter((item) => item.relations.some((r) => item.spec?.type === \"multisig-deployment\" &&\n            r.type === catalog_model_1.RELATION_API_PROVIDED_BY &&\n            r.targetRef === componentRef.targetRef))\n            .map((entity) => ({\n            entity: entity,\n            signers: this.collectSigners(entity),\n            tags: this.getEntityTags(entity),\n        }));\n    }\n    collectSigners(multisig) {\n        return multisig\n            .relations.filter((r) => r.type === catalog_model_1.RELATION_OWNED_BY &&\n            (0, catalog_model_1.parseEntityRef)(r.targetRef).kind !== \"group\")\n            .map((r) => {\n            const signer = this.entityCatalog[r.targetRef];\n            const owner = this.entityCatalog[signer.spec.owner.toString()];\n            return {\n                signer,\n                owner,\n                tags: this.getEntityTags(signer),\n            };\n        })\n            .sort((a, b) => this.sortByName(a.owner, b.owner));\n    }\n}\nexports.MultisigsCollector = MultisigsCollector;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.backstageMetrics = exports.BackstageMetrics = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst datadog_api_client_1 = require(\"@datadog/datadog-api-client\");\nconst metrics_collector_1 = require(\"../core/metrics-collector\");\nconst get_backstage_entities_1 = require(\"../utils/get-backstage-entities\");\nconst configuration = datadog_api_client_1.client.createConfiguration();\nconfiguration.setServerVariables({ site: \"datadoghq.eu\" });\nconst apiInstance = new datadog_api_client_1.v2.MetricsApi(configuration);\nconst DATADOG_GAUGE_TYPE = 3;\nconst SIGNER_POLICY_LIMIT_MS = 180 * 86400 * 1000; // amount of days * seconds in day * milliseconds in second\nclass BackstageMetrics {\n}\nexports.BackstageMetrics = BackstageMetrics;\nasync function backstageMetrics({ backstage_url, testing, }) {\n    if (!backstage_url)\n        return;\n    const entities = await (0, get_backstage_entities_1.getBackstageEntities)({ backstage_url });\n    const collector = new metrics_collector_1.MetricsCollector(entities);\n    try {\n        const multisigSeries = generateMultisigMetrics(collector, backstage_url);\n        const multisigPolicySeries = generateMultisigPolicyMetrics(collector, backstage_url);\n        const signerSeries = generateSignerMetrics(collector, backstage_url);\n        const keySeries = generateAccessKeyMetrics(collector, backstage_url);\n        const keysBySignerSeries = generateSignerAccessKeyMetrics(collector, backstage_url);\n        const keysByContractSeries = generateContractAccessKeyMetrics(collector, backstage_url);\n        const deprecatedKeysSeries = generateDeprecatedAccessKeyMetrics(collector, backstage_url);\n        const unknownAccessKeysSeries = generateUnknownAccessKeyMetrics(collector, backstage_url);\n        const unknownSignerSeries = generateUnknownSignerMetrics(collector, backstage_url);\n        const unknownAddressSeries = generateUnknownAddressMetrics(collector, backstage_url);\n        const inactiveSignerSeries = generateInactiveSignerMetrics(collector, backstage_url);\n        // const unverifiedContractSeries = generateUnverifiedContractsMetrics(multisigsCollector, backstage_url);\n        if (testing) {\n            return [];\n        }\n        const data = await Promise.all([\n            submitMetrics(multisigSeries),\n            submitMetrics(multisigPolicySeries),\n            submitMetrics(signerSeries),\n            submitMetrics(keySeries),\n            submitMetrics(keysBySignerSeries),\n            submitMetrics(keysByContractSeries),\n            submitMetrics(deprecatedKeysSeries),\n            submitMetrics(unknownAccessKeysSeries),\n            submitMetrics(unknownSignerSeries),\n            submitMetrics(unknownAddressSeries),\n            submitMetrics(inactiveSignerSeries),\n            // submitMetrics(unverifiedContractSeries)\n        ]);\n        core.info(`API called successfully. Returned data: ${JSON.stringify(data)}`);\n        return data;\n    }\n    catch (error) {\n        core.error(error);\n    }\n}\nexports.backstageMetrics = backstageMetrics;\nasync function submitMetrics(series) {\n    const params = {\n        body: {\n            series,\n        },\n    };\n    core.info(`Data to upload: ${JSON.stringify(params)}`);\n    return apiInstance.submitMetrics(params);\n}\nfunction generateMultisigMetrics(collector, backstageUrl) {\n    const series = collector.getMultisigs().map((multisig) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = multisig.entity;\n        const { name } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(multisig.entity.spec));\n        const { address, network, networkType, system: rawSystem, owner: rawOwner, } = spec;\n        const system = rawSystem.split(\":\")[1];\n        const owner = rawOwner.split(\":\")[1];\n        const timestamp = Math.round(new Date(spec.multisig.fetchDate).getTime() / 1000);\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"api\", name },\n            { type: \"address\", name: address },\n            { type: \"kind\", name: kind },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"system\", name: system },\n            { type: \"owner\", name: owner },\n        ];\n        const { version } = spec.multisig;\n        // datadog requires point value to be scalar\n        const value = parseFloat(version);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.multisigs.version\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateMultisigPolicyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getMultisigPolicies()\n        .map((multisigPolicyData) => {\n        const { kind, spec } = multisigPolicyData.entity;\n        const { address, network, networkType, system: rawSystem, owner: rawOwner, } = spec;\n        const system = rawSystem ? rawSystem.split(\":\")[1] : \"none\";\n        const owner = rawOwner.split(\":\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"address\", name: address },\n            { type: \"kind\", name: kind },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"system\", name: system },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar\n        const value = multisigPolicyData.policy;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.multisigs.policy\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateSignerMetrics(collector, backstageUrl) {\n    const series = collector.getSigners().map((signer) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = signer.signer;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar, 0 means unknown ownership\n        const value = namespace === \"stub\" ? 0 : 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.signers\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateUnknownSignerMetrics(collector, backstageUrl) {\n    const unknownSigners = collector\n        .getSigners()\n        .filter((entry) => entry.signer.metadata.tags?.includes(\"stub\") ||\n        entry.signer.metadata.namespace === \"stub\");\n    const series = unknownSigners.map((signer) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = signer.signer;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar, 0 means unknown ownership\n        const value = 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.signers.unknown\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction generateUnverifiedContractsMetrics(collector, backstageUrl) {\n    const unverifiedContracts = collector\n        .getAllApis()\n        .filter((entity) => entity.metadata.tags?.includes(\"unverified\"));\n    const series = unverifiedContracts.map((entity) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = entity;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(entity.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar, 0 means unknown ownership\n        const value = 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.reports.unverified=contracts\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateUnknownAddressMetrics(collector, backstageUrl) {\n    const stubAndStateEntities = collector\n        .getAllResources()\n        .filter((entry) => entry.metadata.tags?.includes(\"stub\") &&\n        entry.metadata.tags?.includes(\"contract-state\"));\n    const series = stubAndStateEntities.map((entity) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = entity;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(entity.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        // datadog requires point value to be scalar, 0 means unknown ownership\n        const value = 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.reports.unknown-addresses\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateAccessKeyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getMultisigAccessKeys()\n        .map((key) => {\n        // entities are typically emitted as Resource kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = key;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(key.spec));\n        const { owner: rawOwner } = spec;\n        const [ownerKind, ownerRef] = rawOwner.split(\":\");\n        const ownerName = ownerRef.split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"owner\", name: ownerName },\n            { type: \"ownerKind\", name: ownerKind },\n        ];\n        const value = namespace === \"stub\" || ownerKind !== \"user\" ? 0 : 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.access_keys\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateDeprecatedAccessKeyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getDeprecatedAccessKeys()\n        .map((key) => {\n        // entities are typically emitted as Resource kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = key;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(key.spec));\n        const { owner: rawOwner } = spec;\n        const [ownerKind, ownerRef] = rawOwner.split(\":\");\n        const ownerName = ownerRef.split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"owner\", name: ownerName },\n            { type: \"ownerKind\", name: ownerKind },\n        ];\n        const value = ownerKind !== \"user\" ? 0 : 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.access_keys.deprecated\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateUnknownAccessKeyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getUnknownAccessKeys()\n        .map((key) => {\n        // entities are typically emitted as Resource kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = key;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(key.spec));\n        const { owner: rawOwner } = spec;\n        const [ownerKind, ownerRef] = rawOwner.split(\":\");\n        const ownerName = ownerRef.split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"owner\", name: ownerName },\n            { type: \"ownerKind\", name: ownerKind },\n        ];\n        const value = 1;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.access_keys.unknown\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateSignerAccessKeyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getAccessKeysPerSigner()\n        .filter((entry) => !entry.entity.metadata.tags?.includes(\"deprecated\"))\n        .map(({ entity, keys }) => {\n        const { type, address, network, networkType, owner: rawOwner, } = entity.spec;\n        const owner = rawOwner.split(\":\")[1];\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"type\", name: type },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        const value = keys.length;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.signers.access_keys\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateContractAccessKeyMetrics(collector, backstageUrl) {\n    const series = collector\n        .getAccessKeysPerContract()\n        .filter((entry) => !entry.entity.metadata.tags?.includes(\"deprecated\"))\n        .map(({ entity, component: rawComponent, keys }) => {\n        const { type, address, network, networkType, system: rawSystem, owner: rawOwner, } = entity.spec;\n        const component = rawComponent ? rawComponent.split(\":\")[1] : \"none\";\n        const system = rawSystem ? rawSystem.split(\":\")[1] : \"none\";\n        const owner = rawOwner.split(\":\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"type\", name: type },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"component\", name: component },\n            { type: \"system\", name: system },\n            { type: \"owner\", name: owner },\n        ];\n        const value = keys.length;\n        const timestamp = Math.round(new Date().getTime() / 1000);\n        const points = [{ timestamp, value }];\n        return {\n            metric: \"backstage.contracts.access_keys\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\nfunction generateInactiveSignerMetrics(collector, backstageUrl) {\n    const series = collector.getSigners().map((entity) => {\n        // entities are typically emitted as API kind,\n        // tracking for inconsistencies\n        const { kind, metadata } = entity.signer;\n        const { name, namespace } = metadata;\n        // inferred type is JsonObject, this converts to any\n        const spec = JSON.parse(JSON.stringify(entity.signer.spec));\n        const { address, network, networkType, owner: rawOwner } = spec;\n        const owner = rawOwner.split(\":\")[1].split(\"/\")[1];\n        // this tags timeseries with distinguishing\n        // properties for filtering purposes\n        const resources = [\n            {\n                type: \"host\",\n                name: backstageUrl.split(\"@\")[1],\n            },\n            { type: \"kind\", name: kind },\n            { type: \"name\", name },\n            { type: \"namespace\", name: namespace },\n            { type: \"address\", name: address },\n            { type: \"network\", name: network },\n            { type: \"networkType\", name: networkType },\n            { type: \"owner\", name: owner },\n        ];\n        const now = new Date().getTime();\n        const isPastThreshold = now - Number(spec.lastSigned) > SIGNER_POLICY_LIMIT_MS;\n        const value = isPastThreshold ? 1 : 0;\n        const points = [{ timestamp: now, value }];\n        return {\n            metric: \"backstage.signers.inactive\",\n            type: DATADOG_GAUGE_TYPE,\n            points,\n            resources,\n        };\n    });\n    return series;\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBackstageEntities = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst catalog_client_1 = require(\"@backstage/catalog-client\");\nconst simple_git_1 = require(\"simple-git\");\nconst getBackstageEntities = async ({ backstage_url: backstageUrl, backstage_entities_repo: backstageEntitiesRepo, }) => {\n    if (backstageUrl) {\n        try {\n            return fetchBackstageEntitiesFromURL(backstageUrl);\n        }\n        catch (err) {\n            /* empty */\n        }\n    }\n    // repo used as fallback to the URL in order to avoid unnecessary runtime\n    // dependency\n    if (backstageEntitiesRepo) {\n        return fetchBackstageEntitiesFromRepo(backstageEntitiesRepo);\n    }\n    throw new Error(\"Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action\");\n};\nexports.getBackstageEntities = getBackstageEntities;\nasync function getFileContentFromRepo(repoUrl, filePath) {\n    const cloneDir = `/tmp/github-helpers-${Date.now()}`;\n    const git = (0, simple_git_1.simpleGit)();\n    try {\n        await git.clone(repoUrl, cloneDir, [\"--depth=1\"]);\n        await git.cwd(cloneDir);\n        const { current } = await git.branch();\n        const defaultBranch = current || \"main\";\n        const fileContent = await git.show([\n            `${defaultBranch}:${filePath}`,\n        ]);\n        await git.raw([\"rm\", \"-rf\", \".\"]);\n        return fileContent;\n    }\n    catch (error) {\n        throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n    }\n}\nasync function fetchBackstageEntitiesFromURL(backstageUrl) {\n    core.info(\"Connecting to Backstage to fetch available entities\");\n    const discoveryApi = {\n        async getBaseUrl() {\n            return `${backstageUrl}/api/catalog`;\n        },\n    };\n    const catalogClient = new catalog_client_1.CatalogClient({\n        discoveryApi,\n    });\n    const entities = await catalogClient.getEntities({});\n    core.info(`Total backstage entities: ${entities.items.length}`);\n    return entities.items;\n}\nasync function fetchBackstageEntitiesFromRepo(backstageEntitiesRepo) {\n    const serverUrl = process.env.GITHUB_SERVER_URL || \"https://github.com\";\n    const repoUrl = `${serverUrl}/${backstageEntitiesRepo}`;\n    core.info(`Cloning ${repoUrl}`);\n    const content = await getFileContentFromRepo(repoUrl, \"filteredEntities.json\");\n    return JSON.parse(content);\n}\n"],"names":[],"sourceRoot":""}